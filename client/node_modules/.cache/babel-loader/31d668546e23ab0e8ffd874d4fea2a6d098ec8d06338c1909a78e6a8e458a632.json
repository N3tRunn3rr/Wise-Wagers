{"ast":null,"code":"import _defineProperty from \"/Users/kenjifleming/course-challenges/Perfect-Parlay/perfect-parlay/client/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/Users/kenjifleming/course-challenges/Perfect-Parlay/perfect-parlay/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/Users/kenjifleming/course-challenges/Perfect-Parlay/perfect-parlay/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nvar _defKindToExtKind;\nimport { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isTypeDefinitionNode } from '../../language/predicates.mjs';\nimport { isEnumType, isInputObjectType, isInterfaceType, isObjectType, isScalarType, isUnionType } from '../../type/definition.mjs';\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nexport function PossibleTypeExtensionsRule(context) {\n  var schema = context.getSchema();\n  var definedTypes = Object.create(null);\n  var _iterator = _createForOfIteratorHelper(context.getDocument().definitions),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var def = _step.value;\n      if (isTypeDefinitionNode(def)) {\n        definedTypes[def.name.value] = def;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension\n  };\n  function checkExtension(node) {\n    var typeName = node.name.value;\n    var defNode = definedTypes[typeName];\n    var existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    var expectedKind;\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        var kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(new GraphQLError(\"Cannot extend non-\".concat(kindStr, \" type \\\"\").concat(typeName, \"\\\".\"), {\n          nodes: defNode ? [defNode, node] : node\n        }));\n      }\n    } else {\n      var allTypeNames = Object.keys(_objectSpread(_objectSpread({}, definedTypes), schema === null || schema === void 0 ? void 0 : schema.getTypeMap()));\n      var suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(new GraphQLError(\"Cannot extend type \\\"\".concat(typeName, \"\\\" because it is not defined.\") + didYouMean(suggestedTypes), {\n        nodes: node.name\n      }));\n    }\n  }\n}\nvar defKindToExtKind = (_defKindToExtKind = {}, _defineProperty(_defKindToExtKind, Kind.SCALAR_TYPE_DEFINITION, Kind.SCALAR_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.OBJECT_TYPE_DEFINITION, Kind.OBJECT_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INTERFACE_TYPE_DEFINITION, Kind.INTERFACE_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.UNION_TYPE_DEFINITION, Kind.UNION_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.ENUM_TYPE_DEFINITION, Kind.ENUM_TYPE_EXTENSION), _defineProperty(_defKindToExtKind, Kind.INPUT_OBJECT_TYPE_DEFINITION, Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  }\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable. All possible types have been considered\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n    // Not reachable. All possible types have been considered\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(kind));\n  }\n}","map":{"version":3,"names":["didYouMean","inspect","invariant","suggestionList","GraphQLError","Kind","isTypeDefinitionNode","isEnumType","isInputObjectType","isInterfaceType","isObjectType","isScalarType","isUnionType","PossibleTypeExtensionsRule","context","schema","getSchema","definedTypes","Object","create","_iterator","_createForOfIteratorHelper","getDocument","definitions","_step","s","n","done","def","value","name","err","e","f","ScalarTypeExtension","checkExtension","ObjectTypeExtension","InterfaceTypeExtension","UnionTypeExtension","EnumTypeExtension","InputObjectTypeExtension","node","typeName","defNode","existingType","getType","expectedKind","defKindToExtKind","kind","typeToExtKind","kindStr","extensionKindToTypeName","reportError","concat","nodes","allTypeNames","keys","_objectSpread","getTypeMap","suggestedTypes","_defKindToExtKind","_defineProperty","SCALAR_TYPE_DEFINITION","SCALAR_TYPE_EXTENSION","OBJECT_TYPE_DEFINITION","OBJECT_TYPE_EXTENSION","INTERFACE_TYPE_DEFINITION","INTERFACE_TYPE_EXTENSION","UNION_TYPE_DEFINITION","UNION_TYPE_EXTENSION","ENUM_TYPE_DEFINITION","ENUM_TYPE_EXTENSION","INPUT_OBJECT_TYPE_DEFINITION","INPUT_OBJECT_TYPE_EXTENSION","type"],"sources":["/Users/kenjifleming/course-challenges/Perfect-Parlay/perfect-parlay/client/node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs"],"sourcesContent":["import { didYouMean } from '../../jsutils/didYouMean.mjs';\nimport { inspect } from '../../jsutils/inspect.mjs';\nimport { invariant } from '../../jsutils/invariant.mjs';\nimport { suggestionList } from '../../jsutils/suggestionList.mjs';\nimport { GraphQLError } from '../../error/GraphQLError.mjs';\nimport { Kind } from '../../language/kinds.mjs';\nimport { isTypeDefinitionNode } from '../../language/predicates.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInterfaceType,\n  isObjectType,\n  isScalarType,\n  isUnionType,\n} from '../../type/definition.mjs';\n\n/**\n * Possible type extension\n *\n * A type extension is only valid if the type is defined and has the same kind.\n */\nexport function PossibleTypeExtensionsRule(context) {\n  const schema = context.getSchema();\n  const definedTypes = Object.create(null);\n\n  for (const def of context.getDocument().definitions) {\n    if (isTypeDefinitionNode(def)) {\n      definedTypes[def.name.value] = def;\n    }\n  }\n\n  return {\n    ScalarTypeExtension: checkExtension,\n    ObjectTypeExtension: checkExtension,\n    InterfaceTypeExtension: checkExtension,\n    UnionTypeExtension: checkExtension,\n    EnumTypeExtension: checkExtension,\n    InputObjectTypeExtension: checkExtension,\n  };\n\n  function checkExtension(node) {\n    const typeName = node.name.value;\n    const defNode = definedTypes[typeName];\n    const existingType =\n      schema === null || schema === void 0 ? void 0 : schema.getType(typeName);\n    let expectedKind;\n\n    if (defNode) {\n      expectedKind = defKindToExtKind[defNode.kind];\n    } else if (existingType) {\n      expectedKind = typeToExtKind(existingType);\n    }\n\n    if (expectedKind) {\n      if (expectedKind !== node.kind) {\n        const kindStr = extensionKindToTypeName(node.kind);\n        context.reportError(\n          new GraphQLError(`Cannot extend non-${kindStr} type \"${typeName}\".`, {\n            nodes: defNode ? [defNode, node] : node,\n          }),\n        );\n      }\n    } else {\n      const allTypeNames = Object.keys({\n        ...definedTypes,\n        ...(schema === null || schema === void 0\n          ? void 0\n          : schema.getTypeMap()),\n      });\n      const suggestedTypes = suggestionList(typeName, allTypeNames);\n      context.reportError(\n        new GraphQLError(\n          `Cannot extend type \"${typeName}\" because it is not defined.` +\n            didYouMean(suggestedTypes),\n          {\n            nodes: node.name,\n          },\n        ),\n      );\n    }\n  }\n}\nconst defKindToExtKind = {\n  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,\n  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,\n  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,\n  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,\n  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,\n  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION,\n};\n\nfunction typeToExtKind(type) {\n  if (isScalarType(type)) {\n    return Kind.SCALAR_TYPE_EXTENSION;\n  }\n\n  if (isObjectType(type)) {\n    return Kind.OBJECT_TYPE_EXTENSION;\n  }\n\n  if (isInterfaceType(type)) {\n    return Kind.INTERFACE_TYPE_EXTENSION;\n  }\n\n  if (isUnionType(type)) {\n    return Kind.UNION_TYPE_EXTENSION;\n  }\n\n  if (isEnumType(type)) {\n    return Kind.ENUM_TYPE_EXTENSION;\n  }\n\n  if (isInputObjectType(type)) {\n    return Kind.INPUT_OBJECT_TYPE_EXTENSION;\n  }\n  /* c8 ignore next 3 */\n  // Not reachable. All possible types have been considered\n\n  false || invariant(false, 'Unexpected type: ' + inspect(type));\n}\n\nfunction extensionKindToTypeName(kind) {\n  switch (kind) {\n    case Kind.SCALAR_TYPE_EXTENSION:\n      return 'scalar';\n\n    case Kind.OBJECT_TYPE_EXTENSION:\n      return 'object';\n\n    case Kind.INTERFACE_TYPE_EXTENSION:\n      return 'interface';\n\n    case Kind.UNION_TYPE_EXTENSION:\n      return 'union';\n\n    case Kind.ENUM_TYPE_EXTENSION:\n      return 'enum';\n\n    case Kind.INPUT_OBJECT_TYPE_EXTENSION:\n      return 'input object';\n    // Not reachable. All possible types have been considered\n\n    /* c8 ignore next */\n\n    default:\n      false || invariant(false, 'Unexpected kind: ' + inspect(kind));\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}