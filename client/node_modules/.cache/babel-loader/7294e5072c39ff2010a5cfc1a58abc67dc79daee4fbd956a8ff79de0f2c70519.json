{"ast":null,"code":"import _toConsumableArray from \"/Users/kenjifleming/course-challenges/Perfect-Parlay/perfect-parlay/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { parseValue } from '../language/parser.mjs';\nimport { assertInterfaceType, assertNullableType, assertObjectType, GraphQLEnumType, GraphQLInputObjectType, GraphQLInterfaceType, GraphQLList, GraphQLNonNull, GraphQLObjectType, GraphQLScalarType, GraphQLUnionType, isInputType, isOutputType } from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { introspectionTypes, TypeKind } from '../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../type/scalars.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(false, \"Invalid or incomplete introspection result. Ensure that you are passing \\\"data\\\" property of introspection response and no \\\"errors\\\" was returned alongside: \".concat(inspect(introspection), \".\")); // Get the schema from the introspection result.\n\n  var schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  var typeMap = keyValMap(schemaIntrospection.types, function (typeIntrospection) {\n    return typeIntrospection.name;\n  }, function (typeIntrospection) {\n    return buildType(typeIntrospection);\n  }); // Include standard types only if they are used.\n\n  for (var _i = 0, _arr = [].concat(_toConsumableArray(specifiedScalarTypes), _toConsumableArray(introspectionTypes)); _i < _arr.length; _i++) {\n    var stdType = _arr[_i];\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;\n  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;\n  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: Object.values(typeMap),\n    directives: directives,\n    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      var itemRef = typeRef.ofType;\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n      return new GraphQLList(getType(itemRef));\n    }\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      var nullableRef = typeRef.ofType;\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n      var nullableType = getType(nullableRef);\n      return new GraphQLNonNull(assertNullableType(nullableType));\n    }\n    return getNamedType(typeRef);\n  }\n  function getNamedType(typeRef) {\n    var typeName = typeRef.name;\n    if (!typeName) {\n      throw new Error(\"Unknown type reference: \".concat(inspect(typeRef), \".\"));\n    }\n    var type = typeMap[typeName];\n    if (!type) {\n      throw new Error(\"Invalid or incomplete schema, unknown type: \".concat(typeName, \". Ensure that a full introspection query is used in order to build a client schema.\"));\n    }\n    return type;\n  }\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n  function buildType(type) {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (type != null && type.name != null && type.kind != null) {\n      // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n    var typeStr = inspect(type);\n    throw new Error(\"Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: \".concat(typeStr, \".\"));\n  }\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByURL: scalarIntrospection.specifiedByURL\n    });\n  }\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {\n      return [];\n    }\n    if (!implementingIntrospection.interfaces) {\n      var implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(\"Introspection result missing interfaces: \".concat(implementingIntrospectionStr, \".\"));\n    }\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(objectIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(objectIntrospection);\n      }\n    });\n  }\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: function interfaces() {\n        return buildImplementationsList(interfaceIntrospection);\n      },\n      fields: function fields() {\n        return buildFieldDefMap(interfaceIntrospection);\n      }\n    });\n  }\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      var unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(\"Introspection result missing possibleTypes: \".concat(unionIntrospectionStr, \".\"));\n    }\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: function types() {\n        return unionIntrospection.possibleTypes.map(getObjectType);\n      }\n    });\n  }\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      var enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(\"Introspection result missing enumValues: \".concat(enumIntrospectionStr, \".\"));\n    }\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(enumIntrospection.enumValues, function (valueIntrospection) {\n        return valueIntrospection.name;\n      }, function (valueIntrospection) {\n        return {\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason\n        };\n      })\n    });\n  }\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      var inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(\"Introspection result missing inputFields: \".concat(inputObjectIntrospectionStr, \".\"));\n    }\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: function fields() {\n        return buildInputValueDefMap(inputObjectIntrospection.inputFields);\n      }\n    });\n  }\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\"Introspection result missing fields: \".concat(inspect(typeIntrospection), \".\"));\n    }\n    return keyValMap(typeIntrospection.fields, function (fieldIntrospection) {\n      return fieldIntrospection.name;\n    }, buildField);\n  }\n  function buildField(fieldIntrospection) {\n    var type = getType(fieldIntrospection.type);\n    if (!isOutputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide output type for fields, but received: \".concat(typeStr, \".\"));\n    }\n    if (!fieldIntrospection.args) {\n      var fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(\"Introspection result missing field args: \".concat(fieldIntrospectionStr, \".\"));\n    }\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type: type,\n      args: buildInputValueDefMap(fieldIntrospection.args)\n    };\n  }\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(inputValueIntrospections, function (inputValue) {\n      return inputValue.name;\n    }, buildInputValue);\n  }\n  function buildInputValue(inputValueIntrospection) {\n    var type = getType(inputValueIntrospection.type);\n    if (!isInputType(type)) {\n      var typeStr = inspect(type);\n      throw new Error(\"Introspection must provide input type for arguments, but received: \".concat(typeStr, \".\"));\n    }\n    var defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type) : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type: type,\n      defaultValue: defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason\n    };\n  }\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      var directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\"Introspection result missing directive args: \".concat(directiveIntrospectionStr, \".\"));\n    }\n    if (!directiveIntrospection.locations) {\n      var _directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\"Introspection result missing directive locations: \".concat(_directiveIntrospectionStr, \".\"));\n    }\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args)\n    });\n  }\n}","map":{"version":3,"names":["devAssert","inspect","isObjectLike","keyValMap","parseValue","assertInterfaceType","assertNullableType","assertObjectType","GraphQLEnumType","GraphQLInputObjectType","GraphQLInterfaceType","GraphQLList","GraphQLNonNull","GraphQLObjectType","GraphQLScalarType","GraphQLUnionType","isInputType","isOutputType","GraphQLDirective","introspectionTypes","TypeKind","specifiedScalarTypes","GraphQLSchema","valueFromAST","buildClientSchema","introspection","options","__schema","concat","schemaIntrospection","typeMap","types","typeIntrospection","name","buildType","_i","_arr","_toConsumableArray","length","stdType","queryType","getObjectType","mutationType","subscriptionType","directives","map","buildDirective","description","query","mutation","subscription","Object","values","assumeValid","getType","typeRef","kind","LIST","itemRef","ofType","Error","NON_NULL","nullableRef","nullableType","getNamedType","typeName","type","getInterfaceType","SCALAR","buildScalarDef","OBJECT","buildObjectDef","INTERFACE","buildInterfaceDef","UNION","buildUnionDef","ENUM","buildEnumDef","INPUT_OBJECT","buildInputObjectDef","typeStr","scalarIntrospection","specifiedByURL","buildImplementationsList","implementingIntrospection","interfaces","implementingIntrospectionStr","objectIntrospection","fields","buildFieldDefMap","interfaceIntrospection","unionIntrospection","possibleTypes","unionIntrospectionStr","enumIntrospection","enumValues","enumIntrospectionStr","valueIntrospection","deprecationReason","inputObjectIntrospection","inputFields","inputObjectIntrospectionStr","buildInputValueDefMap","fieldIntrospection","buildField","args","fieldIntrospectionStr","inputValueIntrospections","inputValue","buildInputValue","inputValueIntrospection","defaultValue","undefined","directiveIntrospection","directiveIntrospectionStr","locations","isRepeatable","slice"],"sources":["/Users/kenjifleming/course-challenges/Perfect-Parlay/perfect-parlay/client/node_modules/graphql/utilities/buildClientSchema.mjs"],"sourcesContent":["import { devAssert } from '../jsutils/devAssert.mjs';\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { isObjectLike } from '../jsutils/isObjectLike.mjs';\nimport { keyValMap } from '../jsutils/keyValMap.mjs';\nimport { parseValue } from '../language/parser.mjs';\nimport {\n  assertInterfaceType,\n  assertNullableType,\n  assertObjectType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLScalarType,\n  GraphQLUnionType,\n  isInputType,\n  isOutputType,\n} from '../type/definition.mjs';\nimport { GraphQLDirective } from '../type/directives.mjs';\nimport { introspectionTypes, TypeKind } from '../type/introspection.mjs';\nimport { specifiedScalarTypes } from '../type/scalars.mjs';\nimport { GraphQLSchema } from '../type/schema.mjs';\nimport { valueFromAST } from './valueFromAST.mjs';\n/**\n * Build a GraphQLSchema for use by client tools.\n *\n * Given the result of a client running the introspection query, creates and\n * returns a GraphQLSchema instance which can be then used with all graphql-js\n * tools, but cannot be used to execute a query, as introspection does not\n * represent the \"resolver\", \"parse\" or \"serialize\" functions or any other\n * server-internal mechanisms.\n *\n * This function expects a complete introspection result. Don't forget to check\n * the \"errors\" field of a server response before calling this function.\n */\n\nexport function buildClientSchema(introspection, options) {\n  (isObjectLike(introspection) && isObjectLike(introspection.__schema)) ||\n    devAssert(\n      false,\n      `Invalid or incomplete introspection result. Ensure that you are passing \"data\" property of introspection response and no \"errors\" was returned alongside: ${inspect(\n        introspection,\n      )}.`,\n    ); // Get the schema from the introspection result.\n\n  const schemaIntrospection = introspection.__schema; // Iterate through all types, getting the type definition for each.\n\n  const typeMap = keyValMap(\n    schemaIntrospection.types,\n    (typeIntrospection) => typeIntrospection.name,\n    (typeIntrospection) => buildType(typeIntrospection),\n  ); // Include standard types only if they are used.\n\n  for (const stdType of [...specifiedScalarTypes, ...introspectionTypes]) {\n    if (typeMap[stdType.name]) {\n      typeMap[stdType.name] = stdType;\n    }\n  } // Get the root Query, Mutation, and Subscription types.\n\n  const queryType = schemaIntrospection.queryType\n    ? getObjectType(schemaIntrospection.queryType)\n    : null;\n  const mutationType = schemaIntrospection.mutationType\n    ? getObjectType(schemaIntrospection.mutationType)\n    : null;\n  const subscriptionType = schemaIntrospection.subscriptionType\n    ? getObjectType(schemaIntrospection.subscriptionType)\n    : null; // Get the directives supported by Introspection, assuming empty-set if\n  // directives were not queried for.\n\n  const directives = schemaIntrospection.directives\n    ? schemaIntrospection.directives.map(buildDirective)\n    : []; // Then produce and return a Schema with these types.\n\n  return new GraphQLSchema({\n    description: schemaIntrospection.description,\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types: Object.values(typeMap),\n    directives,\n    assumeValid:\n      options === null || options === void 0 ? void 0 : options.assumeValid,\n  }); // Given a type reference in introspection, return the GraphQLType instance.\n  // preferring cached instances before building new instances.\n\n  function getType(typeRef) {\n    if (typeRef.kind === TypeKind.LIST) {\n      const itemRef = typeRef.ofType;\n\n      if (!itemRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      return new GraphQLList(getType(itemRef));\n    }\n\n    if (typeRef.kind === TypeKind.NON_NULL) {\n      const nullableRef = typeRef.ofType;\n\n      if (!nullableRef) {\n        throw new Error('Decorated type deeper than introspection query.');\n      }\n\n      const nullableType = getType(nullableRef);\n      return new GraphQLNonNull(assertNullableType(nullableType));\n    }\n\n    return getNamedType(typeRef);\n  }\n\n  function getNamedType(typeRef) {\n    const typeName = typeRef.name;\n\n    if (!typeName) {\n      throw new Error(`Unknown type reference: ${inspect(typeRef)}.`);\n    }\n\n    const type = typeMap[typeName];\n\n    if (!type) {\n      throw new Error(\n        `Invalid or incomplete schema, unknown type: ${typeName}. Ensure that a full introspection query is used in order to build a client schema.`,\n      );\n    }\n\n    return type;\n  }\n\n  function getObjectType(typeRef) {\n    return assertObjectType(getNamedType(typeRef));\n  }\n\n  function getInterfaceType(typeRef) {\n    return assertInterfaceType(getNamedType(typeRef));\n  } // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n\n  function buildType(type) {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (type != null && type.name != null && type.kind != null) {\n      // FIXME: Properly type IntrospectionType, it's a breaking change so fix in v17\n      // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n      switch (type.kind) {\n        case TypeKind.SCALAR:\n          return buildScalarDef(type);\n\n        case TypeKind.OBJECT:\n          return buildObjectDef(type);\n\n        case TypeKind.INTERFACE:\n          return buildInterfaceDef(type);\n\n        case TypeKind.UNION:\n          return buildUnionDef(type);\n\n        case TypeKind.ENUM:\n          return buildEnumDef(type);\n\n        case TypeKind.INPUT_OBJECT:\n          return buildInputObjectDef(type);\n      }\n    }\n\n    const typeStr = inspect(type);\n    throw new Error(\n      `Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${typeStr}.`,\n    );\n  }\n\n  function buildScalarDef(scalarIntrospection) {\n    return new GraphQLScalarType({\n      name: scalarIntrospection.name,\n      description: scalarIntrospection.description,\n      specifiedByURL: scalarIntrospection.specifiedByURL,\n    });\n  }\n\n  function buildImplementationsList(implementingIntrospection) {\n    // TODO: Temporary workaround until GraphQL ecosystem will fully support\n    // 'interfaces' on interface types.\n    if (\n      implementingIntrospection.interfaces === null &&\n      implementingIntrospection.kind === TypeKind.INTERFACE\n    ) {\n      return [];\n    }\n\n    if (!implementingIntrospection.interfaces) {\n      const implementingIntrospectionStr = inspect(implementingIntrospection);\n      throw new Error(\n        `Introspection result missing interfaces: ${implementingIntrospectionStr}.`,\n      );\n    }\n\n    return implementingIntrospection.interfaces.map(getInterfaceType);\n  }\n\n  function buildObjectDef(objectIntrospection) {\n    return new GraphQLObjectType({\n      name: objectIntrospection.name,\n      description: objectIntrospection.description,\n      interfaces: () => buildImplementationsList(objectIntrospection),\n      fields: () => buildFieldDefMap(objectIntrospection),\n    });\n  }\n\n  function buildInterfaceDef(interfaceIntrospection) {\n    return new GraphQLInterfaceType({\n      name: interfaceIntrospection.name,\n      description: interfaceIntrospection.description,\n      interfaces: () => buildImplementationsList(interfaceIntrospection),\n      fields: () => buildFieldDefMap(interfaceIntrospection),\n    });\n  }\n\n  function buildUnionDef(unionIntrospection) {\n    if (!unionIntrospection.possibleTypes) {\n      const unionIntrospectionStr = inspect(unionIntrospection);\n      throw new Error(\n        `Introspection result missing possibleTypes: ${unionIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLUnionType({\n      name: unionIntrospection.name,\n      description: unionIntrospection.description,\n      types: () => unionIntrospection.possibleTypes.map(getObjectType),\n    });\n  }\n\n  function buildEnumDef(enumIntrospection) {\n    if (!enumIntrospection.enumValues) {\n      const enumIntrospectionStr = inspect(enumIntrospection);\n      throw new Error(\n        `Introspection result missing enumValues: ${enumIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLEnumType({\n      name: enumIntrospection.name,\n      description: enumIntrospection.description,\n      values: keyValMap(\n        enumIntrospection.enumValues,\n        (valueIntrospection) => valueIntrospection.name,\n        (valueIntrospection) => ({\n          description: valueIntrospection.description,\n          deprecationReason: valueIntrospection.deprecationReason,\n        }),\n      ),\n    });\n  }\n\n  function buildInputObjectDef(inputObjectIntrospection) {\n    if (!inputObjectIntrospection.inputFields) {\n      const inputObjectIntrospectionStr = inspect(inputObjectIntrospection);\n      throw new Error(\n        `Introspection result missing inputFields: ${inputObjectIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLInputObjectType({\n      name: inputObjectIntrospection.name,\n      description: inputObjectIntrospection.description,\n      fields: () => buildInputValueDefMap(inputObjectIntrospection.inputFields),\n    });\n  }\n\n  function buildFieldDefMap(typeIntrospection) {\n    if (!typeIntrospection.fields) {\n      throw new Error(\n        `Introspection result missing fields: ${inspect(typeIntrospection)}.`,\n      );\n    }\n\n    return keyValMap(\n      typeIntrospection.fields,\n      (fieldIntrospection) => fieldIntrospection.name,\n      buildField,\n    );\n  }\n\n  function buildField(fieldIntrospection) {\n    const type = getType(fieldIntrospection.type);\n\n    if (!isOutputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(\n        `Introspection must provide output type for fields, but received: ${typeStr}.`,\n      );\n    }\n\n    if (!fieldIntrospection.args) {\n      const fieldIntrospectionStr = inspect(fieldIntrospection);\n      throw new Error(\n        `Introspection result missing field args: ${fieldIntrospectionStr}.`,\n      );\n    }\n\n    return {\n      description: fieldIntrospection.description,\n      deprecationReason: fieldIntrospection.deprecationReason,\n      type,\n      args: buildInputValueDefMap(fieldIntrospection.args),\n    };\n  }\n\n  function buildInputValueDefMap(inputValueIntrospections) {\n    return keyValMap(\n      inputValueIntrospections,\n      (inputValue) => inputValue.name,\n      buildInputValue,\n    );\n  }\n\n  function buildInputValue(inputValueIntrospection) {\n    const type = getType(inputValueIntrospection.type);\n\n    if (!isInputType(type)) {\n      const typeStr = inspect(type);\n      throw new Error(\n        `Introspection must provide input type for arguments, but received: ${typeStr}.`,\n      );\n    }\n\n    const defaultValue =\n      inputValueIntrospection.defaultValue != null\n        ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type)\n        : undefined;\n    return {\n      description: inputValueIntrospection.description,\n      type,\n      defaultValue,\n      deprecationReason: inputValueIntrospection.deprecationReason,\n    };\n  }\n\n  function buildDirective(directiveIntrospection) {\n    if (!directiveIntrospection.args) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\n        `Introspection result missing directive args: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    if (!directiveIntrospection.locations) {\n      const directiveIntrospectionStr = inspect(directiveIntrospection);\n      throw new Error(\n        `Introspection result missing directive locations: ${directiveIntrospectionStr}.`,\n      );\n    }\n\n    return new GraphQLDirective({\n      name: directiveIntrospection.name,\n      description: directiveIntrospection.description,\n      isRepeatable: directiveIntrospection.isRepeatable,\n      locations: directiveIntrospection.locations.slice(),\n      args: buildInputValueDefMap(directiveIntrospection.args),\n    });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}