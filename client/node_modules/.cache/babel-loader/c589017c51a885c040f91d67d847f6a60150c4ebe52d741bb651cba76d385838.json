{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { invariant } from \"../../utilities/globals/index.js\";\nimport { useCallback, useContext, useMemo, useRef, useState } from 'react';\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nimport { equal } from '@wry/equality';\nimport { mergeOptions } from \"../../core/index.js\";\nimport { getApolloContext } from \"../context/index.js\";\nimport { ApolloError } from \"../../errors/index.js\";\nimport { NetworkStatus } from \"../../core/index.js\";\nimport { DocumentType, verifyDocumentType } from \"../parser/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { canUseWeakMap, canUseWeakSet, compact, isNonEmptyArray, maybeDeepFreeze } from \"../../utilities/index.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function useQuery(query, options) {\n  if (options === void 0) {\n    options = Object.create(null);\n  }\n  return useInternalState(useApolloClient(options.client), query).useQuery(options);\n}\nexport function useInternalState(client, query) {\n  var stateRef = useRef();\n  if (!stateRef.current || client !== stateRef.current.client || query !== stateRef.current.query) {\n    stateRef.current = new InternalState(client, query, stateRef.current);\n  }\n  var state = stateRef.current;\n  var _a = useState(0),\n    _tick = _a[0],\n    setTick = _a[1];\n  state.forceUpdate = function () {\n    setTick(function (tick) {\n      return tick + 1;\n    });\n  };\n  return state;\n}\nvar InternalState = function () {\n  function InternalState(client, query, previous) {\n    this.client = client;\n    this.query = query;\n    this.asyncResolveFns = new Set();\n    this.optionsToIgnoreOnce = new (canUseWeakSet ? WeakSet : Set)();\n    this.ssrDisabledResult = maybeDeepFreeze({\n      loading: true,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.loading\n    });\n    this.skipStandbyResult = maybeDeepFreeze({\n      loading: false,\n      data: void 0,\n      error: void 0,\n      networkStatus: NetworkStatus.ready\n    });\n    this.toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)();\n    verifyDocumentType(query, DocumentType.Query);\n    var previousResult = previous && previous.result;\n    var previousData = previousResult && previousResult.data;\n    if (previousData) {\n      this.previousData = previousData;\n    }\n  }\n  InternalState.prototype.forceUpdate = function () {\n    __DEV__ && invariant.warn(\"Calling default no-op implementation of InternalState#forceUpdate\");\n  };\n  InternalState.prototype.asyncUpdate = function (signal) {\n    var _this = this;\n    return new Promise(function (resolve, reject) {\n      var watchQueryOptions = _this.watchQueryOptions;\n      var handleAborted = function handleAborted() {\n        _this.asyncResolveFns.delete(resolve);\n        _this.optionsToIgnoreOnce.delete(watchQueryOptions);\n        signal.removeEventListener('abort', handleAborted);\n        reject(signal.reason);\n      };\n      _this.asyncResolveFns.add(resolve);\n      _this.optionsToIgnoreOnce.add(watchQueryOptions);\n      signal.addEventListener('abort', handleAborted);\n      _this.forceUpdate();\n    });\n  };\n  InternalState.prototype.useQuery = function (options) {\n    var _this = this;\n    this.renderPromises = useContext(getApolloContext()).renderPromises;\n    this.useOptions(options);\n    var obsQuery = this.useObservableQuery();\n    var result = useSyncExternalStore(useCallback(function () {\n      if (_this.renderPromises) {\n        return function () {};\n      }\n      var onNext = function onNext() {\n        var previousResult = _this.result;\n        var result = obsQuery.getCurrentResult();\n        if (previousResult && previousResult.loading === result.loading && previousResult.networkStatus === result.networkStatus && equal(previousResult.data, result.data)) {\n          return;\n        }\n        _this.setResult(result);\n      };\n      var onError = function onError(error) {\n        var last = obsQuery[\"last\"];\n        subscription.unsubscribe();\n        try {\n          obsQuery.resetLastResults();\n          subscription = obsQuery.subscribe(onNext, onError);\n        } finally {\n          obsQuery[\"last\"] = last;\n        }\n        if (!hasOwnProperty.call(error, 'graphQLErrors')) {\n          throw error;\n        }\n        var previousResult = _this.result;\n        if (!previousResult || previousResult && previousResult.loading || !equal(error, previousResult.error)) {\n          _this.setResult({\n            data: previousResult && previousResult.data,\n            error: error,\n            loading: false,\n            networkStatus: NetworkStatus.error\n          });\n        }\n      };\n      var subscription = obsQuery.subscribe(onNext, onError);\n      return function () {\n        return subscription.unsubscribe();\n      };\n    }, [obsQuery, this.renderPromises, this.client.disableNetworkFetches]), function () {\n      return _this.getCurrentResult();\n    }, function () {\n      return _this.getCurrentResult();\n    });\n    this.unsafeHandlePartialRefetch(result);\n    var queryResult = this.toQueryResult(result);\n    if (!queryResult.loading && this.asyncResolveFns.size) {\n      this.asyncResolveFns.forEach(function (resolve) {\n        return resolve(queryResult);\n      });\n      this.asyncResolveFns.clear();\n    }\n    return queryResult;\n  };\n  InternalState.prototype.useOptions = function (options) {\n    var _a;\n    var watchQueryOptions = this.createWatchQueryOptions(this.queryHookOptions = options);\n    var currentWatchQueryOptions = this.watchQueryOptions;\n    if (this.optionsToIgnoreOnce.has(currentWatchQueryOptions) || !equal(watchQueryOptions, currentWatchQueryOptions)) {\n      this.watchQueryOptions = watchQueryOptions;\n      if (currentWatchQueryOptions && this.observable) {\n        this.optionsToIgnoreOnce.delete(currentWatchQueryOptions);\n        this.observable.reobserve(this.getObsQueryOptions());\n        this.previousData = ((_a = this.result) === null || _a === void 0 ? void 0 : _a.data) || this.previousData;\n        this.result = void 0;\n      }\n    }\n    this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n    if ((this.renderPromises || this.client.disableNetworkFetches) && this.queryHookOptions.ssr === false && !this.queryHookOptions.skip) {\n      this.result = this.ssrDisabledResult;\n    } else if (this.queryHookOptions.skip || this.watchQueryOptions.fetchPolicy === 'standby') {\n      this.result = this.skipStandbyResult;\n    } else if (this.result === this.ssrDisabledResult || this.result === this.skipStandbyResult) {\n      this.result = void 0;\n    }\n  };\n  InternalState.prototype.getObsQueryOptions = function () {\n    var toMerge = [];\n    var globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n    if (this.queryHookOptions.defaultOptions) {\n      toMerge.push(this.queryHookOptions.defaultOptions);\n    }\n    toMerge.push(compact(this.observable && this.observable.options, this.watchQueryOptions));\n    return toMerge.reduce(mergeOptions);\n  };\n  InternalState.prototype.createWatchQueryOptions = function (_a) {\n    var _b;\n    if (_a === void 0) {\n      _a = {};\n    }\n    var skip = _a.skip,\n      ssr = _a.ssr,\n      onCompleted = _a.onCompleted,\n      onError = _a.onError,\n      defaultOptions = _a.defaultOptions,\n      otherOptions = __rest(_a, [\"skip\", \"ssr\", \"onCompleted\", \"onError\", \"defaultOptions\"]);\n    var watchQueryOptions = Object.assign(otherOptions, {\n      query: this.query\n    });\n    if (this.renderPromises && (watchQueryOptions.fetchPolicy === 'network-only' || watchQueryOptions.fetchPolicy === 'cache-and-network')) {\n      watchQueryOptions.fetchPolicy = 'cache-first';\n    }\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {};\n    }\n    if (skip) {\n      var _c = watchQueryOptions.fetchPolicy,\n        fetchPolicy = _c === void 0 ? this.getDefaultFetchPolicy() : _c,\n        _d = watchQueryOptions.initialFetchPolicy,\n        initialFetchPolicy = _d === void 0 ? fetchPolicy : _d;\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy: initialFetchPolicy,\n        fetchPolicy: 'standby'\n      });\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy = ((_b = this.observable) === null || _b === void 0 ? void 0 : _b.options.initialFetchPolicy) || this.getDefaultFetchPolicy();\n    }\n    return watchQueryOptions;\n  };\n  InternalState.prototype.getDefaultFetchPolicy = function () {\n    var _a, _b;\n    return ((_a = this.queryHookOptions.defaultOptions) === null || _a === void 0 ? void 0 : _a.fetchPolicy) || ((_b = this.client.defaultOptions.watchQuery) === null || _b === void 0 ? void 0 : _b.fetchPolicy) || \"cache-first\";\n  };\n  InternalState.prototype.onCompleted = function (data) {};\n  InternalState.prototype.onError = function (error) {};\n  InternalState.prototype.useObservableQuery = function () {\n    var obsQuery = this.observable = this.renderPromises && this.renderPromises.getSSRObservable(this.watchQueryOptions) || this.observable || this.client.watchQuery(this.getObsQueryOptions());\n    this.obsQueryFields = useMemo(function () {\n      return {\n        refetch: obsQuery.refetch.bind(obsQuery),\n        reobserve: obsQuery.reobserve.bind(obsQuery),\n        fetchMore: obsQuery.fetchMore.bind(obsQuery),\n        updateQuery: obsQuery.updateQuery.bind(obsQuery),\n        startPolling: obsQuery.startPolling.bind(obsQuery),\n        stopPolling: obsQuery.stopPolling.bind(obsQuery),\n        subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery)\n      };\n    }, [obsQuery]);\n    var ssrAllowed = !(this.queryHookOptions.ssr === false || this.queryHookOptions.skip);\n    if (this.renderPromises && ssrAllowed) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n      if (obsQuery.getCurrentResult().loading) {\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n    return obsQuery;\n  };\n  InternalState.prototype.setResult = function (nextResult) {\n    var previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult);\n  };\n  InternalState.prototype.handleErrorOrCompleted = function (result) {\n    var _this = this;\n    if (!result.loading) {\n      var error_1 = this.toApolloError(result);\n      Promise.resolve().then(function () {\n        if (error_1) {\n          _this.onError(error_1);\n        } else if (result.data) {\n          _this.onCompleted(result.data);\n        }\n      }).catch(function (error) {\n        __DEV__ && invariant.warn(error);\n      });\n    }\n  };\n  InternalState.prototype.toApolloError = function (result) {\n    return isNonEmptyArray(result.errors) ? new ApolloError({\n      graphQLErrors: result.errors\n    }) : result.error;\n  };\n  InternalState.prototype.getCurrentResult = function () {\n    if (!this.result) {\n      this.handleErrorOrCompleted(this.result = this.observable.getCurrentResult());\n    }\n    return this.result;\n  };\n  InternalState.prototype.toQueryResult = function (result) {\n    var queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n    var data = result.data,\n      partial = result.partial,\n      resultWithoutPartial = __rest(result, [\"data\", \"partial\"]);\n    this.toQueryResultCache.set(result, queryResult = __assign(__assign(__assign({\n      data: data\n    }, resultWithoutPartial), this.obsQueryFields), {\n      client: this.client,\n      observable: this.observable,\n      variables: this.observable.variables,\n      called: !this.queryHookOptions.skip,\n      previousData: this.previousData\n    }));\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      queryResult.error = new ApolloError({\n        graphQLErrors: result.errors\n      });\n    }\n    return queryResult;\n  };\n  InternalState.prototype.unsafeHandlePartialRefetch = function (result) {\n    if (result.partial && this.queryHookOptions.partialRefetch && !result.loading && (!result.data || Object.keys(result.data).length === 0) && this.observable.options.fetchPolicy !== 'cache-only') {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch\n      });\n      this.observable.refetch();\n    }\n  };\n  return InternalState;\n}();","map":{"version":3,"names":["invariant","useCallback","useContext","useMemo","useRef","useState","useSyncExternalStore","equal","mergeOptions","getApolloContext","ApolloError","NetworkStatus","DocumentType","verifyDocumentType","useApolloClient","canUseWeakMap","canUseWeakSet","compact","isNonEmptyArray","maybeDeepFreeze","hasOwnProperty","Object","prototype","useQuery","query","options","create","useInternalState","client","stateRef","current","InternalState","state","_a","_tick","setTick","forceUpdate","tick","previous","asyncResolveFns","Set","optionsToIgnoreOnce","WeakSet","ssrDisabledResult","loading","data","error","networkStatus","skipStandbyResult","ready","toQueryResultCache","WeakMap","Map","Query","previousResult","result","previousData","__DEV__","warn","asyncUpdate","signal","_this","Promise","resolve","reject","watchQueryOptions","handleAborted","delete","removeEventListener","reason","add","addEventListener","renderPromises","useOptions","obsQuery","useObservableQuery","onNext","getCurrentResult","setResult","onError","last","subscription","unsubscribe","resetLastResults","subscribe","call","disableNetworkFetches","unsafeHandlePartialRefetch","queryResult","toQueryResult","size","forEach","clear","createWatchQueryOptions","queryHookOptions","currentWatchQueryOptions","has","observable","reobserve","getObsQueryOptions","onCompleted","ssr","skip","fetchPolicy","toMerge","globalDefaults","defaultOptions","watchQuery","push","reduce","otherOptions","__rest","assign","variables","_c","getDefaultFetchPolicy","_d","initialFetchPolicy","_b","getSSRObservable","obsQueryFields","refetch","bind","fetchMore","updateQuery","startPolling","stopPolling","subscribeToMore","ssrAllowed","registerSSRObservable","addObservableQueryPromise","nextResult","handleErrorOrCompleted","error_1","toApolloError","then","catch","errors","graphQLErrors","get","partial","resultWithoutPartial","set","__assign","called","partialRefetch","keys","length"],"sources":["/Users/kenjifleming/course-challenges/Perfect-Parlay/perfect-parlay/client/node_modules/@apollo/src/react/hooks/useQuery.ts"],"sourcesContent":["import { invariant } from '../../utilities/globals';\n\nimport {\n  useCallback,\n  useContext,\n  useMemo,\n  useRef,\n  useState,\n} from 'react';\nimport { useSyncExternalStore } from './useSyncExternalStore';\nimport { equal } from '@wry/equality';\n\nimport { mergeOptions, OperationVariables, WatchQueryFetchPolicy } from '../../core';\nimport { ApolloContextValue, getApolloContext } from '../context';\nimport { ApolloError } from '../../errors';\nimport {\n  ApolloClient,\n  ApolloQueryResult,\n  NetworkStatus,\n  ObservableQuery,\n  DocumentNode,\n  TypedDocumentNode,\n  WatchQueryOptions,\n} from '../../core';\nimport {\n  QueryHookOptions,\n  QueryResult,\n  ObservableQueryFields,\n} from '../types/types';\n\nimport { DocumentType, verifyDocumentType } from '../parser';\nimport { useApolloClient } from './useApolloClient';\nimport { canUseWeakMap, canUseWeakSet, compact, isNonEmptyArray, maybeDeepFreeze } from '../../utilities';\n\nconst {\n  prototype: {\n    hasOwnProperty,\n  },\n} = Object;\n\nexport function useQuery<\n  TData = any,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: QueryHookOptions<TData, TVariables> = Object.create(null),\n): QueryResult<TData, TVariables> {\n  return useInternalState(\n    useApolloClient(options.client),\n    query,\n  ).useQuery(options);\n}\n\nexport function useInternalState<TData, TVariables extends OperationVariables>(\n  client: ApolloClient<any>,\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n): InternalState<TData, TVariables> {\n  const stateRef = useRef<InternalState<TData, TVariables>>();\n  if (\n    !stateRef.current ||\n    client !== stateRef.current.client ||\n    query !== stateRef.current.query\n  ) {\n    stateRef.current = new InternalState(client, query, stateRef.current);\n  }\n  const state = stateRef.current;\n\n  // By default, InternalState.prototype.forceUpdate is an empty function, but\n  // we replace it here (before anyone has had a chance to see this state yet)\n  // with a function that unconditionally forces an update, using the latest\n  // setTick function. Updating this state by calling state.forceUpdate is the\n  // only way we trigger React component updates (no other useState calls within\n  // the InternalState class).\n  const [_tick, setTick] = useState(0);\n  state.forceUpdate = () => {\n    setTick(tick => tick + 1);\n  };\n\n  return state;\n}\n\nclass InternalState<TData, TVariables extends OperationVariables> {\n  constructor(\n    public readonly client: ReturnType<typeof useApolloClient>,\n    public readonly query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    previous?: InternalState<TData, TVariables>,\n  ) {\n    verifyDocumentType(query, DocumentType.Query);\n\n    // Reuse previousData from previous InternalState (if any) to provide\n    // continuity of previousData even if/when the query or client changes.\n    const previousResult = previous && previous.result;\n    const previousData = previousResult && previousResult.data;\n    if (previousData) {\n      this.previousData = previousData;\n    }\n  }\n\n  forceUpdate() {\n    // Replaced (in useInternalState) with a method that triggers an update.\n    invariant.warn(\"Calling default no-op implementation of InternalState#forceUpdate\");\n  }\n\n  asyncUpdate(signal: AbortSignal) {\n    return new Promise<QueryResult<TData, TVariables>>((resolve, reject) => {\n      const watchQueryOptions = this.watchQueryOptions;\n\n      const handleAborted = () => {\n        this.asyncResolveFns.delete(resolve)\n        this.optionsToIgnoreOnce.delete(watchQueryOptions);\n        signal.removeEventListener('abort', handleAborted)\n        reject(signal.reason);\n      };\n\n      this.asyncResolveFns.add(resolve);\n      this.optionsToIgnoreOnce.add(watchQueryOptions);\n      signal.addEventListener('abort', handleAborted)\n      this.forceUpdate();\n    });\n  }\n\n  private asyncResolveFns = new Set<\n    (result: QueryResult<TData, TVariables>) => void\n  >();\n\n  private optionsToIgnoreOnce = new (canUseWeakSet ? WeakSet : Set)<\n    WatchQueryOptions<TVariables, TData>\n  >();\n\n  // Methods beginning with use- should be called according to the standard\n  // rules of React hooks: only at the top level of the calling function, and\n  // without any dynamic conditional logic.\n  useQuery(options: QueryHookOptions<TData, TVariables>) {\n    // The renderPromises field gets initialized here in the useQuery method, at\n    // the beginning of everything (for a given component rendering, at least),\n    // so we can safely use this.renderPromises in other/later InternalState\n    // methods without worrying it might be uninitialized. Even after\n    // initialization, this.renderPromises is usually undefined (unless SSR is\n    // happening), but that's fine as long as it has been initialized that way,\n    // rather than left uninitialized.\n    this.renderPromises = useContext(getApolloContext()).renderPromises;\n\n    this.useOptions(options);\n\n    const obsQuery = this.useObservableQuery();\n\n    const result = useSyncExternalStore(\n      useCallback(() => {\n        if (this.renderPromises) {\n          return () => {};\n        }\n\n        const onNext = () => {\n          const previousResult = this.result;\n          // We use `getCurrentResult()` instead of the onNext argument because\n          // the values differ slightly. Specifically, loading results will have\n          // an empty object for data instead of `undefined` for some reason.\n          const result = obsQuery.getCurrentResult();\n          // Make sure we're not attempting to re-render similar results\n          if (\n            previousResult &&\n            previousResult.loading === result.loading &&\n            previousResult.networkStatus === result.networkStatus &&\n            equal(previousResult.data, result.data)\n          ) {\n            return;\n          }\n\n          this.setResult(result);\n        };\n\n        const onError = (error: Error) => {\n          const last = obsQuery[\"last\"];\n          subscription.unsubscribe();\n          // Unfortunately, if `lastError` is set in the current\n          // `observableQuery` when the subscription is re-created,\n          // the subscription will immediately receive the error, which will\n          // cause it to terminate again. To avoid this, we first clear\n          // the last error/result from the `observableQuery` before re-starting\n          // the subscription, and restore it afterwards (so the subscription\n          // has a chance to stay open).\n          try {\n            obsQuery.resetLastResults();\n            subscription = obsQuery.subscribe(onNext, onError);\n          } finally {\n            obsQuery[\"last\"] = last;\n          }\n\n          if (!hasOwnProperty.call(error, 'graphQLErrors')) {\n            // The error is not a GraphQL error\n            throw error;\n          }\n\n          const previousResult = this.result;\n          if (\n            !previousResult ||\n            (previousResult && previousResult.loading) ||\n            !equal(error, previousResult.error)\n          ) {\n            this.setResult({\n              data: (previousResult && previousResult.data) as TData,\n              error: error as ApolloError,\n              loading: false,\n              networkStatus: NetworkStatus.error,\n            });\n          }\n        };\n\n        let subscription = obsQuery.subscribe(onNext, onError);\n\n        return () => subscription.unsubscribe();\n      }, [\n        // We memoize the subscribe function using useCallback and the following\n        // dependency keys, because the subscribe function reference is all that\n        // useSyncExternalStore uses internally as a dependency key for the\n        // useEffect ultimately responsible for the subscription, so we are\n        // effectively passing this dependency array to that useEffect buried\n        // inside useSyncExternalStore, as desired.\n        obsQuery,\n        this.renderPromises,\n        this.client.disableNetworkFetches,\n      ]),\n\n      () => this.getCurrentResult(),\n      () => this.getCurrentResult(),\n    );\n\n    // TODO Remove this method when we remove support for options.partialRefetch.\n    this.unsafeHandlePartialRefetch(result);\n\n    const queryResult = this.toQueryResult(result);\n\n    if (!queryResult.loading && this.asyncResolveFns.size) {\n      this.asyncResolveFns.forEach(resolve => resolve(queryResult));\n      this.asyncResolveFns.clear();\n    }\n\n    return queryResult;\n  }\n\n  // These members (except for renderPromises) are all populated by the\n  // useOptions method, which is called unconditionally at the beginning of the\n  // useQuery method, so we can safely use these members in other/later methods\n  // without worrying they might be uninitialized.\n  private renderPromises: ApolloContextValue[\"renderPromises\"];\n  private queryHookOptions: QueryHookOptions<TData, TVariables>;\n  private watchQueryOptions: WatchQueryOptions<TVariables, TData>;\n\n  private useOptions(\n    options: QueryHookOptions<TData, TVariables>,\n  ) {\n    const watchQueryOptions = this.createWatchQueryOptions(\n      this.queryHookOptions = options,\n    );\n\n    // Update this.watchQueryOptions, but only when they have changed, which\n    // allows us to depend on the referential stability of\n    // this.watchQueryOptions elsewhere.\n    const currentWatchQueryOptions = this.watchQueryOptions;\n\n    // To force this equality test to \"fail,\" thereby reliably triggering\n    // observable.reobserve, add any current WatchQueryOptions object(s) you\n    // want to be ignored to this.optionsToIgnoreOnce. A similar effect could be\n    // achieved by nullifying this.watchQueryOptions so the equality test\n    // immediately fails because currentWatchQueryOptions is null, but this way\n    // we can promise a truthy this.watchQueryOptions at all times.\n    if (\n      this.optionsToIgnoreOnce.has(currentWatchQueryOptions) ||\n      !equal(watchQueryOptions, currentWatchQueryOptions)\n    ) {\n      this.watchQueryOptions = watchQueryOptions;\n\n      if (currentWatchQueryOptions && this.observable) {\n        // As advertised in the -Once of this.optionsToIgnoreOnce, this trick is\n        // only good for one forced execution of observable.reobserve per\n        // ignored WatchQueryOptions object, though it is unlikely we will ever\n        // see this exact currentWatchQueryOptions object again here, since we\n        // just replaced this.watchQueryOptions with watchQueryOptions.\n        this.optionsToIgnoreOnce.delete(currentWatchQueryOptions);\n\n        // Though it might be tempting to postpone this reobserve call to the\n        // useEffect block, we need getCurrentResult to return an appropriate\n        // loading:true result synchronously (later within the same call to\n        // useQuery). Since we already have this.observable here (not true for\n        // the very first call to useQuery), we are not initiating any new\n        // subscriptions, though it does feel less than ideal that reobserve\n        // (potentially) kicks off a network request (for example, when the\n        // variables have changed), which is technically a side-effect.\n        this.observable.reobserve(this.getObsQueryOptions());\n\n        // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n        // but save the current data as this.previousData, just like setResult\n        // usually does.\n        this.previousData = this.result?.data || this.previousData;\n        this.result = void 0;\n      }\n    }\n\n    // Make sure state.onCompleted and state.onError always reflect the latest\n    // options.onCompleted and options.onError callbacks provided to useQuery,\n    // since those functions are often recreated every time useQuery is called.\n    // Like the forceUpdate method, the versions of these methods inherited from\n    // InternalState.prototype are empty no-ops, but we can override them on the\n    // base state object (without modifying the prototype).\n    this.onCompleted = options.onCompleted || InternalState.prototype.onCompleted;\n    this.onError = options.onError || InternalState.prototype.onError;\n\n    if (\n      (this.renderPromises || this.client.disableNetworkFetches) &&\n      this.queryHookOptions.ssr === false &&\n      !this.queryHookOptions.skip\n    ) {\n      // If SSR has been explicitly disabled, and this function has been called\n      // on the server side, return the default loading state.\n      this.result = this.ssrDisabledResult;\n    } else if (\n      this.queryHookOptions.skip ||\n      this.watchQueryOptions.fetchPolicy === 'standby'\n    ) {\n      // When skipping a query (ie. we're not querying for data but still want to\n      // render children), make sure the `data` is cleared out and `loading` is\n      // set to `false` (since we aren't loading anything).\n      //\n      // NOTE: We no longer think this is the correct behavior. Skipping should\n      // not automatically set `data` to `undefined`, but instead leave the\n      // previous data in place. In other words, skipping should not mandate that\n      // previously received data is all of a sudden removed. Unfortunately,\n      // changing this is breaking, so we'll have to wait until Apollo Client 4.0\n      // to address this.\n      this.result = this.skipStandbyResult;\n    } else if (\n      this.result === this.ssrDisabledResult ||\n      this.result === this.skipStandbyResult\n    ) {\n      this.result = void 0;\n    }\n  }\n\n  private getObsQueryOptions(): WatchQueryOptions<TVariables, TData> {\n    const toMerge: Array<\n      Partial<WatchQueryOptions<TVariables, TData>>\n    > = [];\n\n    const globalDefaults = this.client.defaultOptions.watchQuery;\n    if (globalDefaults) toMerge.push(globalDefaults);\n\n    if (this.queryHookOptions.defaultOptions) {\n      toMerge.push(this.queryHookOptions.defaultOptions);\n    }\n\n    // We use compact rather than mergeOptions for this part of the merge,\n    // because we want watchQueryOptions.variables (if defined) to replace\n    // this.observable.options.variables whole. This replacement allows\n    // removing variables by removing them from the variables input to\n    // useQuery. If the variables were always merged together (rather than\n    // replaced), there would be no way to remove existing variables.\n    // However, the variables from options.defaultOptions and globalDefaults\n    // (if provided) should be merged, to ensure individual defaulted\n    // variables always have values, if not otherwise defined in\n    // observable.options or watchQueryOptions.\n    toMerge.push(compact(\n      this.observable && this.observable.options,\n      this.watchQueryOptions,\n    ));\n\n    return toMerge.reduce(\n      mergeOptions\n    ) as WatchQueryOptions<TVariables, TData>;\n  }\n\n  private ssrDisabledResult = maybeDeepFreeze({\n    loading: true,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.loading,\n  });\n\n  private skipStandbyResult = maybeDeepFreeze({\n    loading: false,\n    data: void 0 as unknown as TData,\n    error: void 0,\n    networkStatus: NetworkStatus.ready,\n  });\n\n  // A function to massage options before passing them to ObservableQuery.\n  private createWatchQueryOptions({\n    skip,\n    ssr,\n    onCompleted,\n    onError,\n    defaultOptions,\n    // The above options are useQuery-specific, so this ...otherOptions spread\n    // makes otherOptions almost a WatchQueryOptions object, except for the\n    // query property that we add below.\n    ...otherOptions\n  }: QueryHookOptions<TData, TVariables> = {}): WatchQueryOptions<TVariables, TData> {\n    // This Object.assign is safe because otherOptions is a fresh ...rest object\n    // that did not exist until just now, so modifications are still allowed.\n    const watchQueryOptions: WatchQueryOptions<TVariables, TData> =\n      Object.assign(otherOptions, { query: this.query });\n\n    if (\n      this.renderPromises &&\n      (\n        watchQueryOptions.fetchPolicy === 'network-only' ||\n        watchQueryOptions.fetchPolicy === 'cache-and-network'\n      )\n    ) {\n      // this behavior was added to react-apollo without explanation in this PR\n      // https://github.com/apollographql/react-apollo/pull/1579\n      watchQueryOptions.fetchPolicy = 'cache-first';\n    }\n\n    if (!watchQueryOptions.variables) {\n      watchQueryOptions.variables = {} as TVariables;\n    }\n\n    if (skip) {\n      const {\n        fetchPolicy = this.getDefaultFetchPolicy(),\n        initialFetchPolicy = fetchPolicy,\n      } = watchQueryOptions;\n\n      // When skipping, we set watchQueryOptions.fetchPolicy initially to\n      // \"standby\", but we also need/want to preserve the initial non-standby\n      // fetchPolicy that would have been used if not skipping.\n      Object.assign(watchQueryOptions, {\n        initialFetchPolicy,\n        fetchPolicy: 'standby',\n      });\n    } else if (!watchQueryOptions.fetchPolicy) {\n      watchQueryOptions.fetchPolicy =\n        this.observable?.options.initialFetchPolicy ||\n        this.getDefaultFetchPolicy();\n    }\n\n    return watchQueryOptions;\n  }\n\n  getDefaultFetchPolicy(): WatchQueryFetchPolicy {\n    return (\n      this.queryHookOptions.defaultOptions?.fetchPolicy ||\n      this.client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\"\n    );\n  }\n\n  // Defining these methods as no-ops on the prototype allows us to call\n  // state.onCompleted and/or state.onError without worrying about whether a\n  // callback was provided.\n  private onCompleted(data: TData) {}\n  private onError(error: ApolloError) {}\n\n  private observable: ObservableQuery<TData, TVariables>;\n  private obsQueryFields: Omit<\n    ObservableQueryFields<TData, TVariables>,\n    \"variables\"\n  >;\n\n  private useObservableQuery() {\n    // See if there is an existing observable that was used to fetch the same\n    // data and if so, use it instead since it will contain the proper queryId\n    // to fetch the result set. This is used during SSR.\n    const obsQuery = this.observable =\n      this.renderPromises\n        && this.renderPromises.getSSRObservable(this.watchQueryOptions)\n        || this.observable // Reuse this.observable if possible (and not SSR)\n        || this.client.watchQuery(this.getObsQueryOptions());\n\n    this.obsQueryFields = useMemo(() => ({\n      refetch: obsQuery.refetch.bind(obsQuery),\n      reobserve: obsQuery.reobserve.bind(obsQuery),\n      fetchMore: obsQuery.fetchMore.bind(obsQuery),\n      updateQuery: obsQuery.updateQuery.bind(obsQuery),\n      startPolling: obsQuery.startPolling.bind(obsQuery),\n      stopPolling: obsQuery.stopPolling.bind(obsQuery),\n      subscribeToMore: obsQuery.subscribeToMore.bind(obsQuery),\n    }), [obsQuery]);\n\n    const ssrAllowed = !(\n      this.queryHookOptions.ssr === false ||\n      this.queryHookOptions.skip\n    );\n\n    if (this.renderPromises && ssrAllowed) {\n      this.renderPromises.registerSSRObservable(obsQuery);\n\n      if (obsQuery.getCurrentResult().loading) {\n        // TODO: This is a legacy API which could probably be cleaned up\n        this.renderPromises.addObservableQueryPromise(obsQuery);\n      }\n    }\n\n    return obsQuery;\n  }\n\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  private result: undefined | ApolloQueryResult<TData>;\n  private previousData: undefined | TData;\n\n  private setResult(nextResult: ApolloQueryResult<TData>) {\n    const previousResult = this.result;\n    if (previousResult && previousResult.data) {\n      this.previousData = previousResult.data;\n    }\n    this.result = nextResult;\n    // Calling state.setResult always triggers an update, though some call sites\n    // perform additional equality checks before committing to an update.\n    this.forceUpdate();\n    this.handleErrorOrCompleted(nextResult);\n  }\n\n  private handleErrorOrCompleted(result: ApolloQueryResult<TData>) {\n    if (!result.loading) {\n      const error = this.toApolloError(result);\n\n      // wait a tick in case we are in the middle of rendering a component\n      Promise.resolve().then(() => {\n        if (error) {\n          this.onError(error);\n        } else if (result.data) {\n          this.onCompleted(result.data);\n        }\n      }).catch(error => {\n        invariant.warn(error);\n      });\n    }\n  }\n\n  private toApolloError(result: ApolloQueryResult<TData>): ApolloError | undefined {\n    return isNonEmptyArray(result.errors)\n      ? new ApolloError({ graphQLErrors: result.errors })\n      : result.error\n  }\n\n  private getCurrentResult(): ApolloQueryResult<TData> {\n    // Using this.result as a cache ensures getCurrentResult continues returning\n    // the same (===) result object, unless state.setResult has been called, or\n    // we're doing server rendering and therefore override the result below.\n    if (!this.result) {\n      this.handleErrorOrCompleted(\n        this.result = this.observable.getCurrentResult()\n      );\n    }\n    return this.result;\n  }\n\n  // This cache allows the referential stability of this.result (as returned by\n  // getCurrentResult) to translate into referential stability of the resulting\n  // QueryResult object returned by toQueryResult.\n  private toQueryResultCache = new (canUseWeakMap ? WeakMap : Map)<\n    ApolloQueryResult<TData>,\n    QueryResult<TData, TVariables>\n  >();\n\n  toQueryResult(\n    result: ApolloQueryResult<TData>,\n  ): QueryResult<TData, TVariables> {\n    let queryResult = this.toQueryResultCache.get(result);\n    if (queryResult) return queryResult;\n\n    const { data, partial, ...resultWithoutPartial } = result;\n    this.toQueryResultCache.set(result, queryResult = {\n      data, // Ensure always defined, even if result.data is missing.\n      ...resultWithoutPartial,\n      ...this.obsQueryFields,\n      client: this.client,\n      observable: this.observable,\n      variables: this.observable.variables,\n      called: !this.queryHookOptions.skip,\n      previousData: this.previousData,\n    });\n\n    if (!queryResult.error && isNonEmptyArray(result.errors)) {\n      // Until a set naming convention for networkError and graphQLErrors is\n      // decided upon, we map errors (graphQLErrors) to the error options.\n      // TODO: Is it possible for both result.error and result.errors to be\n      // defined here?\n      queryResult.error = new ApolloError({ graphQLErrors: result.errors });\n    }\n\n    return queryResult;\n  }\n\n  private unsafeHandlePartialRefetch(result: ApolloQueryResult<TData>) {\n    // WARNING: SIDE-EFFECTS IN THE RENDER FUNCTION\n    //\n    // TODO: This code should be removed when the partialRefetch option is\n    // removed. I was unable to get this hook to behave reasonably in certain\n    // edge cases when this block was put in an effect.\n    if (\n      result.partial &&\n      this.queryHookOptions.partialRefetch &&\n      !result.loading &&\n      (!result.data || Object.keys(result.data).length === 0) &&\n      this.observable.options.fetchPolicy !== 'cache-only'\n    ) {\n      Object.assign(result, {\n        loading: true,\n        networkStatus: NetworkStatus.refetch,\n      });\n      this.observable.refetch();\n    }\n  }\n}\n"],"mappings":";AAAA,SAASA,SAAS,QAAQ,kCAA0B;AAEpD,SACEC,WAAW,EACXC,UAAU,EACVC,OAAO,EACPC,MAAM,EACNC,QAAQ,QACH,OAAO;AACd,SAASC,oBAAoB,QAAQ,2BAAyB;AAC9D,SAASC,KAAK,QAAQ,eAAe;AAErC,SAASC,YAAY,QAAmD,qBAAa;AACrF,SAA6BC,gBAAgB,QAAQ,qBAAa;AAClE,SAASC,WAAW,QAAQ,uBAAe;AAC3C,SAGEC,aAAa,QAKR,qBAAa;AAOpB,SAASC,YAAY,EAAEC,kBAAkB,QAAQ,oBAAY;AAC7D,SAASC,eAAe,QAAQ,sBAAoB;AACpD,SAASC,aAAa,EAAEC,aAAa,EAAEC,OAAO,EAAEC,eAAe,EAAEC,eAAe,QAAQ,0BAAkB;AAItG,IAAAC,cAAc,GAEdC,MAAM,CAAAC,SAAA,CAAAF,cAFQ;AAIlB,OAAM,SAAUG,QAAQA,CAItBC,KAA0D,EAC1DC,OAAkE;EAAlE,IAAAA,OAAA;IAAAA,OAAA,GAA+CJ,MAAM,CAACK,MAAM,CAAC,IAAI,CAAC;EAAA;EAElE,OAAOC,gBAAgB,CACrBb,eAAe,CAACW,OAAO,CAACG,MAAM,CAAC,EAC/BJ,KAAK,CACN,CAACD,QAAQ,CAACE,OAAO,CAAC;AACrB;AAEA,OAAM,SAAUE,gBAAgBA,CAC9BC,MAAyB,EACzBJ,KAA0D;EAE1D,IAAMK,QAAQ,GAAGzB,MAAM,EAAoC;EAC3D,IACE,CAACyB,QAAQ,CAACC,OAAO,IACjBF,MAAM,KAAKC,QAAQ,CAACC,OAAO,CAACF,MAAM,IAClCJ,KAAK,KAAKK,QAAQ,CAACC,OAAO,CAACN,KAAK,EAChC;IACAK,QAAQ,CAACC,OAAO,GAAG,IAAIC,aAAa,CAACH,MAAM,EAAEJ,KAAK,EAAEK,QAAQ,CAACC,OAAO,CAAC;;EAEvE,IAAME,KAAK,GAAGH,QAAQ,CAACC,OAAO;EAQxB,IAAAG,EAAA,GAAmB5B,QAAQ,CAAC,CAAC,CAAC;IAA7B6B,KAAK,GAAAD,EAAA;IAAEE,OAAO,GAAAF,EAAA,GAAe;EACpCD,KAAK,CAACI,WAAW,GAAG;IAClBD,OAAO,CAAC,UAAAE,IAAI;MAAI,OAAAA,IAAI,GAAG,CAAC;IAAR,CAAQ,CAAC;EAC3B,CAAC;EAED,OAAOL,KAAK;AACd;AAEA,IAAAD,aAAA;EACE,SAAAA,cACkBH,MAA0C,EAC1CJ,KAA0D,EAC1Ec,QAA2C;IAF3B,KAAAV,MAAM,GAANA,MAAM;IACN,KAAAJ,KAAK,GAALA,KAAK;IAqCf,KAAAe,eAAe,GAAG,IAAIC,GAAG,EAE9B;IAEK,KAAAC,mBAAmB,GAAG,KAAKzB,aAAa,GAAG0B,OAAO,GAAGF,GAAG,GAE7D;IAmPK,KAAAG,iBAAiB,GAAGxB,eAAe,CAAC;MAC1CyB,OAAO,EAAE,IAAI;MACbC,IAAI,EAAE,KAAK,CAAqB;MAChCC,KAAK,EAAE,KAAK,CAAC;MACbC,aAAa,EAAEpC,aAAa,CAACiC;KAC9B,CAAC;IAEM,KAAAI,iBAAiB,GAAG7B,eAAe,CAAC;MAC1CyB,OAAO,EAAE,KAAK;MACdC,IAAI,EAAE,KAAK,CAAqB;MAChCC,KAAK,EAAE,KAAK,CAAC;MACbC,aAAa,EAAEpC,aAAa,CAACsC;KAC9B,CAAC;IAyKM,KAAAC,kBAAkB,GAAG,KAAKnC,aAAa,GAAGoC,OAAO,GAAGC,GAAG,GAG5D;IAndDvC,kBAAkB,CAACW,KAAK,EAAEZ,YAAY,CAACyC,KAAK,CAAC;IAI7C,IAAMC,cAAc,GAAGhB,QAAQ,IAAIA,QAAQ,CAACiB,MAAM;IAClD,IAAMC,YAAY,GAAGF,cAAc,IAAIA,cAAc,CAACT,IAAI;IAC1D,IAAIW,YAAY,EAAE;MAChB,IAAI,CAACA,YAAY,GAAGA,YAAY;;EAEpC;EAEAzB,aAAA,CAAAT,SAAA,CAAAc,WAAW,GAAX;IAEEqB,OAAA,IAAUzD,SAAK,CAAA0D,IAAA,oEAAqE;EACtF,CAAC;EAED3B,aAAA,CAAAT,SAAA,CAAAqC,WAAW,GAAX,UAAYC,MAAmB;IAA/B,IAAAC,KAAA;IACE,OAAO,IAAIC,OAAO,CAAiC,UAACC,OAAO,EAAEC,MAAM;MACjE,IAAMC,iBAAiB,GAAGJ,KAAI,CAACI,iBAAiB;MAEhD,IAAMC,aAAa,GAAG,SAAhBA,aAAaA,CAAA,EAAG;QACpBL,KAAI,CAACtB,eAAe,CAAC4B,MAAM,CAACJ,OAAO,CAAC;QACpCF,KAAI,CAACpB,mBAAmB,CAAC0B,MAAM,CAACF,iBAAiB,CAAC;QAClDL,MAAM,CAACQ,mBAAmB,CAAC,OAAO,EAAEF,aAAa,CAAC;QAClDF,MAAM,CAACJ,MAAM,CAACS,MAAM,CAAC;MACvB,CAAC;MAEDR,KAAI,CAACtB,eAAe,CAAC+B,GAAG,CAACP,OAAO,CAAC;MACjCF,KAAI,CAACpB,mBAAmB,CAAC6B,GAAG,CAACL,iBAAiB,CAAC;MAC/CL,MAAM,CAACW,gBAAgB,CAAC,OAAO,EAAEL,aAAa,CAAC;MAC/CL,KAAI,CAACzB,WAAW,EAAE;IACpB,CAAC,CAAC;EACJ,CAAC;EAaDL,aAAA,CAAAT,SAAA,CAAAC,QAAQ,GAAR,UAASE,OAA4C;IAArD,IAAAoC,KAAA;IAQE,IAAI,CAACW,cAAc,GAAGtE,UAAU,CAACO,gBAAgB,EAAE,CAAC,CAAC+D,cAAc;IAEnE,IAAI,CAACC,UAAU,CAAChD,OAAO,CAAC;IAExB,IAAMiD,QAAQ,GAAG,IAAI,CAACC,kBAAkB,EAAE;IAE1C,IAAMpB,MAAM,GAAGjD,oBAAoB,CACjCL,WAAW,CAAC;MACV,IAAI4D,KAAI,CAACW,cAAc,EAAE;QACvB,OAAO,aAAO,CAAC;;MAGjB,IAAMI,MAAM,GAAG,SAATA,MAAMA,CAAA,EAAG;QACb,IAAMtB,cAAc,GAAGO,KAAI,CAACN,MAAM;QAIlC,IAAMA,MAAM,GAAGmB,QAAQ,CAACG,gBAAgB,EAAE;QAE1C,IACEvB,cAAc,IACdA,cAAc,CAACV,OAAO,KAAKW,MAAM,CAACX,OAAO,IACzCU,cAAc,CAACP,aAAa,KAAKQ,MAAM,CAACR,aAAa,IACrDxC,KAAK,CAAC+C,cAAc,CAACT,IAAI,EAAEU,MAAM,CAACV,IAAI,CAAC,EACvC;UACA;;QAGFgB,KAAI,CAACiB,SAAS,CAACvB,MAAM,CAAC;MACxB,CAAC;MAED,IAAMwB,OAAO,GAAG,SAAVA,OAAOA,CAAIjC,KAAY;QAC3B,IAAMkC,IAAI,GAAGN,QAAQ,CAAC,MAAM,CAAC;QAC7BO,YAAY,CAACC,WAAW,EAAE;QAQ1B,IAAI;UACFR,QAAQ,CAACS,gBAAgB,EAAE;UAC3BF,YAAY,GAAGP,QAAQ,CAACU,SAAS,CAACR,MAAM,EAAEG,OAAO,CAAC;SACnD,SAAS;UACRL,QAAQ,CAAC,MAAM,CAAC,GAAGM,IAAI;;QAGzB,IAAI,CAAC5D,cAAc,CAACiE,IAAI,CAACvC,KAAK,EAAE,eAAe,CAAC,EAAE;UAEhD,MAAMA,KAAK;;QAGb,IAAMQ,cAAc,GAAGO,KAAI,CAACN,MAAM;QAClC,IACE,CAACD,cAAc,IACdA,cAAc,IAAIA,cAAc,CAACV,OAAQ,IAC1C,CAACrC,KAAK,CAACuC,KAAK,EAAEQ,cAAc,CAACR,KAAK,CAAC,EACnC;UACAe,KAAI,CAACiB,SAAS,CAAC;YACbjC,IAAI,EAAGS,cAAc,IAAIA,cAAc,CAACT,IAAc;YACtDC,KAAK,EAAEA,KAAoB;YAC3BF,OAAO,EAAE,KAAK;YACdG,aAAa,EAAEpC,aAAa,CAACmC;WAC9B,CAAC;;MAEN,CAAC;MAED,IAAImC,YAAY,GAAGP,QAAQ,CAACU,SAAS,CAACR,MAAM,EAAEG,OAAO,CAAC;MAEtD,OAAO;QAAM,OAAAE,YAAY,CAACC,WAAW,EAAE;MAA1B,CAA0B;IACzC,CAAC,EAAE,CAODR,QAAQ,EACR,IAAI,CAACF,cAAc,EACnB,IAAI,CAAC5C,MAAM,CAAC0D,qBAAqB,CAClC,CAAC,EAEF;MAAM,OAAAzB,KAAI,CAACgB,gBAAgB,EAAE;IAAvB,CAAuB,EAC7B;MAAM,OAAAhB,KAAI,CAACgB,gBAAgB,EAAE;IAAvB,CAAuB,CAC9B;IAGD,IAAI,CAACU,0BAA0B,CAAChC,MAAM,CAAC;IAEvC,IAAMiC,WAAW,GAAG,IAAI,CAACC,aAAa,CAAClC,MAAM,CAAC;IAE9C,IAAI,CAACiC,WAAW,CAAC5C,OAAO,IAAI,IAAI,CAACL,eAAe,CAACmD,IAAI,EAAE;MACrD,IAAI,CAACnD,eAAe,CAACoD,OAAO,CAAC,UAAA5B,OAAO;QAAI,OAAAA,OAAO,CAACyB,WAAW,CAAC;MAApB,CAAoB,CAAC;MAC7D,IAAI,CAACjD,eAAe,CAACqD,KAAK,EAAE;;IAG9B,OAAOJ,WAAW;EACpB,CAAC;EAUOzD,aAAA,CAAAT,SAAA,CAAAmD,UAAU,GAAlB,UACEhD,OAA4C;;IAE5C,IAAMwC,iBAAiB,GAAG,IAAI,CAAC4B,uBAAuB,CACpD,IAAI,CAACC,gBAAgB,GAAGrE,OAAO,CAChC;IAKD,IAAMsE,wBAAwB,GAAG,IAAI,CAAC9B,iBAAiB;IAQvD,IACE,IAAI,CAACxB,mBAAmB,CAACuD,GAAG,CAACD,wBAAwB,CAAC,IACtD,CAACxF,KAAK,CAAC0D,iBAAiB,EAAE8B,wBAAwB,CAAC,EACnD;MACA,IAAI,CAAC9B,iBAAiB,GAAGA,iBAAiB;MAE1C,IAAI8B,wBAAwB,IAAI,IAAI,CAACE,UAAU,EAAE;QAM/C,IAAI,CAACxD,mBAAmB,CAAC0B,MAAM,CAAC4B,wBAAwB,CAAC;QAUzD,IAAI,CAACE,UAAU,CAACC,SAAS,CAAC,IAAI,CAACC,kBAAkB,EAAE,CAAC;QAKpD,IAAI,CAAC3C,YAAY,GAAG,EAAAvB,EAAA,OAAI,CAACsB,MAAM,cAAAtB,EAAA,uBAAAA,EAAA,CAAEY,IAAI,KAAI,IAAI,CAACW,YAAY;QAC1D,IAAI,CAACD,MAAM,GAAG,KAAK,CAAC;;;IAUxB,IAAI,CAAC6C,WAAW,GAAG3E,OAAO,CAAC2E,WAAW,IAAIrE,aAAa,CAACT,SAAS,CAAC8E,WAAW;IAC7E,IAAI,CAACrB,OAAO,GAAGtD,OAAO,CAACsD,OAAO,IAAIhD,aAAa,CAACT,SAAS,CAACyD,OAAO;IAEjE,IACE,CAAC,IAAI,CAACP,cAAc,IAAI,IAAI,CAAC5C,MAAM,CAAC0D,qBAAqB,KACzD,IAAI,CAACQ,gBAAgB,CAACO,GAAG,KAAK,KAAK,IACnC,CAAC,IAAI,CAACP,gBAAgB,CAACQ,IAAI,EAC3B;MAGA,IAAI,CAAC/C,MAAM,GAAG,IAAI,CAACZ,iBAAiB;KACrC,MAAM,IACL,IAAI,CAACmD,gBAAgB,CAACQ,IAAI,IAC1B,IAAI,CAACrC,iBAAiB,CAACsC,WAAW,KAAK,SAAS,EAChD;MAWA,IAAI,CAAChD,MAAM,GAAG,IAAI,CAACP,iBAAiB;KACrC,MAAM,IACL,IAAI,CAACO,MAAM,KAAK,IAAI,CAACZ,iBAAiB,IACtC,IAAI,CAACY,MAAM,KAAK,IAAI,CAACP,iBAAiB,EACtC;MACA,IAAI,CAACO,MAAM,GAAG,KAAK,CAAC;;EAExB,CAAC;EAEOxB,aAAA,CAAAT,SAAA,CAAA6E,kBAAkB,GAA1B;IACE,IAAMK,OAAO,GAET,EAAE;IAEN,IAAMC,cAAc,GAAG,IAAI,CAAC7E,MAAM,CAAC8E,cAAc,CAACC,UAAU;IAC5D,IAAIF,cAAc,EAAED,OAAO,CAACI,IAAI,CAACH,cAAc,CAAC;IAEhD,IAAI,IAAI,CAACX,gBAAgB,CAACY,cAAc,EAAE;MACxCF,OAAO,CAACI,IAAI,CAAC,IAAI,CAACd,gBAAgB,CAACY,cAAc,CAAC;;IAapDF,OAAO,CAACI,IAAI,CAAC3F,OAAO,CAClB,IAAI,CAACgF,UAAU,IAAI,IAAI,CAACA,UAAU,CAACxE,OAAO,EAC1C,IAAI,CAACwC,iBAAiB,CACvB,CAAC;IAEF,OAAOuC,OAAO,CAACK,MAAM,CACnBrG,YAAY,CAC2B;EAC3C,CAAC;EAiBOuB,aAAA,CAAAT,SAAA,CAAAuE,uBAAuB,GAA/B,UAAgC5D,EAUW;;IAVX,IAAAA,EAAA;MAAAA,EAAA,KAUW;IAAA;IATzC,IAAAqE,IAAI,GAAArE,EAAA,CAAAqE,IAAA;MACJD,GAAG,GAAApE,EAAA,CAAAoE,GAAA;MACHD,WAAW,GAAAnE,EAAA,CAAAmE,WAAA;MACXrB,OAAO,GAAA9C,EAAA,CAAA8C,OAAA;MACP2B,cAAc,GAAAzE,EAAA,CAAAyE,cAAA;MAIXI,YAAY,GAAAC,MAAA,CAAA9E,EAAA,EATe,2DAU/B,CADgB;IAIf,IAAMgC,iBAAiB,GACrB5C,MAAM,CAAC2F,MAAM,CAACF,YAAY,EAAE;MAAEtF,KAAK,EAAE,IAAI,CAACA;IAAK,CAAE,CAAC;IAEpD,IACE,IAAI,CAACgD,cAAc,KAEjBP,iBAAiB,CAACsC,WAAW,KAAK,cAAc,IAChDtC,iBAAiB,CAACsC,WAAW,KAAK,mBAAmB,CACtD,EACD;MAGAtC,iBAAiB,CAACsC,WAAW,GAAG,aAAa;;IAG/C,IAAI,CAACtC,iBAAiB,CAACgD,SAAS,EAAE;MAChChD,iBAAiB,CAACgD,SAAS,GAAG,EAAgB;;IAGhD,IAAIX,IAAI,EAAE;MAEN,IAAAY,EAAA,GAEEjD,iBAAiB,CAAAsC,WAFuB;QAA1CA,WAAW,GAAAW,EAAA,cAAG,IAAI,CAACC,qBAAqB,EAAE,GAAAD,EAAA;QAC1CE,EAAA,GACEnD,iBAAiB,CAAAoD,kBADa;QAAhCA,kBAAkB,GAAAD,EAAA,cAAGb,WAAW,GAAAa,EAAA;MAMlC/F,MAAM,CAAC2F,MAAM,CAAC/C,iBAAiB,EAAE;QAC/BoD,kBAAkB,EAAAA,kBAAA;QAClBd,WAAW,EAAE;OACd,CAAC;KACH,MAAM,IAAI,CAACtC,iBAAiB,CAACsC,WAAW,EAAE;MACzCtC,iBAAiB,CAACsC,WAAW,GAC3B,EAAAe,EAAA,OAAI,CAACrB,UAAU,cAAAqB,EAAA,uBAAAA,EAAA,CAAE7F,OAAO,CAAC4F,kBAAkB,KAC3C,IAAI,CAACF,qBAAqB,EAAE;;IAGhC,OAAOlD,iBAAiB;EAC1B,CAAC;EAEDlC,aAAA,CAAAT,SAAA,CAAA6F,qBAAqB,GAArB;;IACE,OACE,EAAAlF,EAAA,OAAI,CAAC6D,gBAAgB,CAACY,cAAc,cAAAzE,EAAA,uBAAAA,EAAA,CAAEsE,WAAW,MACjD,CAAAe,EAAA,OAAI,CAAC1F,MAAM,CAAC8E,cAAc,CAACC,UAAU,cAAAW,EAAA,uBAAAA,EAAA,CAAEf,WAAW,KAClD,aAAa;EAEjB,CAAC;EAKOxE,aAAA,CAAAT,SAAA,CAAA8E,WAAW,GAAnB,UAAoBvD,IAAW,GAAG,CAAC;EAC3Bd,aAAA,CAAAT,SAAA,CAAAyD,OAAO,GAAf,UAAgBjC,KAAkB,GAAG,CAAC;EAQ9Bf,aAAA,CAAAT,SAAA,CAAAqD,kBAAkB,GAA1B;IAIE,IAAMD,QAAQ,GAAG,IAAI,CAACuB,UAAU,GAC9B,IAAI,CAACzB,cAAc,IACd,IAAI,CAACA,cAAc,CAAC+C,gBAAgB,CAAC,IAAI,CAACtD,iBAAiB,CAAC,IAC5D,IAAI,CAACgC,UAAU,IACf,IAAI,CAACrE,MAAM,CAAC+E,UAAU,CAAC,IAAI,CAACR,kBAAkB,EAAE,CAAC;IAExD,IAAI,CAACqB,cAAc,GAAGrH,OAAO,CAAC;MAAM,OAAC;QACnCsH,OAAO,EAAE/C,QAAQ,CAAC+C,OAAO,CAACC,IAAI,CAAChD,QAAQ,CAAC;QACxCwB,SAAS,EAAExB,QAAQ,CAACwB,SAAS,CAACwB,IAAI,CAAChD,QAAQ,CAAC;QAC5CiD,SAAS,EAAEjD,QAAQ,CAACiD,SAAS,CAACD,IAAI,CAAChD,QAAQ,CAAC;QAC5CkD,WAAW,EAAElD,QAAQ,CAACkD,WAAW,CAACF,IAAI,CAAChD,QAAQ,CAAC;QAChDmD,YAAY,EAAEnD,QAAQ,CAACmD,YAAY,CAACH,IAAI,CAAChD,QAAQ,CAAC;QAClDoD,WAAW,EAAEpD,QAAQ,CAACoD,WAAW,CAACJ,IAAI,CAAChD,QAAQ,CAAC;QAChDqD,eAAe,EAAErD,QAAQ,CAACqD,eAAe,CAACL,IAAI,CAAChD,QAAQ;OACxD;IARmC,CAQlC,EAAE,CAACA,QAAQ,CAAC,CAAC;IAEf,IAAMsD,UAAU,GAAG,EACjB,IAAI,CAAClC,gBAAgB,CAACO,GAAG,KAAK,KAAK,IACnC,IAAI,CAACP,gBAAgB,CAACQ,IAAI,CAC3B;IAED,IAAI,IAAI,CAAC9B,cAAc,IAAIwD,UAAU,EAAE;MACrC,IAAI,CAACxD,cAAc,CAACyD,qBAAqB,CAACvD,QAAQ,CAAC;MAEnD,IAAIA,QAAQ,CAACG,gBAAgB,EAAE,CAACjC,OAAO,EAAE;QAEvC,IAAI,CAAC4B,cAAc,CAAC0D,yBAAyB,CAACxD,QAAQ,CAAC;;;IAI3D,OAAOA,QAAQ;EACjB,CAAC;EAOO3C,aAAA,CAAAT,SAAA,CAAAwD,SAAS,GAAjB,UAAkBqD,UAAoC;IACpD,IAAM7E,cAAc,GAAG,IAAI,CAACC,MAAM;IAClC,IAAID,cAAc,IAAIA,cAAc,CAACT,IAAI,EAAE;MACzC,IAAI,CAACW,YAAY,GAAGF,cAAc,CAACT,IAAI;;IAEzC,IAAI,CAACU,MAAM,GAAG4E,UAAU;IAGxB,IAAI,CAAC/F,WAAW,EAAE;IAClB,IAAI,CAACgG,sBAAsB,CAACD,UAAU,CAAC;EACzC,CAAC;EAEOpG,aAAA,CAAAT,SAAA,CAAA8G,sBAAsB,GAA9B,UAA+B7E,MAAgC;IAA/D,IAAAM,KAAA;IACE,IAAI,CAACN,MAAM,CAACX,OAAO,EAAE;MACnB,IAAMyF,OAAK,GAAG,IAAI,CAACC,aAAa,CAAC/E,MAAM,CAAC;MAGxCO,OAAO,CAACC,OAAO,EAAE,CAACwE,IAAI,CAAC;QACrB,IAAIF,OAAK,EAAE;UACTxE,KAAI,CAACkB,OAAO,CAACsD,OAAK,CAAC;SACpB,MAAM,IAAI9E,MAAM,CAACV,IAAI,EAAE;UACtBgB,KAAI,CAACuC,WAAW,CAAC7C,MAAM,CAACV,IAAI,CAAC;;MAEjC,CAAC,CAAC,CAAC2F,KAAK,CAAC,UAAA1F,KAAK;QACZW,OAAA,IAAUzD,SAAU,CAAC0D,IAAC,CAAAZ,KAAA;MACxB,CAAC,CAAC;;EAEN,CAAC;EAEOf,aAAA,CAAAT,SAAA,CAAAgH,aAAa,GAArB,UAAsB/E,MAAgC;IACpD,OAAOrC,eAAe,CAACqC,MAAM,CAACkF,MAAM,CAAC,GACjC,IAAI/H,WAAW,CAAC;MAAEgI,aAAa,EAAEnF,MAAM,CAACkF;IAAM,CAAE,CAAC,GACjDlF,MAAM,CAACT,KAAK;EAClB,CAAC;EAEOf,aAAA,CAAAT,SAAA,CAAAuD,gBAAgB,GAAxB;IAIE,IAAI,CAAC,IAAI,CAACtB,MAAM,EAAE;MAChB,IAAI,CAAC6E,sBAAsB,CACzB,IAAI,CAAC7E,MAAM,GAAG,IAAI,CAAC0C,UAAU,CAACpB,gBAAgB,EAAE,CACjD;;IAEH,OAAO,IAAI,CAACtB,MAAM;EACpB,CAAC;EAUDxB,aAAA,CAAAT,SAAA,CAAAmE,aAAa,GAAb,UACElC,MAAgC;IAEhC,IAAIiC,WAAW,GAAG,IAAI,CAACtC,kBAAkB,CAACyF,GAAG,CAACpF,MAAM,CAAC;IACrD,IAAIiC,WAAW,EAAE,OAAOA,WAAW;IAE3B,IAAA3C,IAAI,GAAuCU,MAAM,CAAAV,IAA7C;MAAE+F,OAAO,GAA8BrF,MAAM,CAAAqF,OAApC;MAAKC,oBAAoB,GAAA9B,MAAA,CAAKxD,MAAM,EAAnD,mBAA0C,CAAF;IAC9C,IAAI,CAACL,kBAAkB,CAAC4F,GAAG,CAACvF,MAAM,EAAEiC,WAAW,GAAAuD,QAAA,CAAAA,QAAA,CAAAA,QAAA;MAC7ClG,IAAI,EAAAA;IAAA,GACDgG,oBAAoB,GACpB,IAAI,CAACrB,cAAc;MACtB5F,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBqE,UAAU,EAAE,IAAI,CAACA,UAAU;MAC3BgB,SAAS,EAAE,IAAI,CAAChB,UAAU,CAACgB,SAAS;MACpC+B,MAAM,EAAE,CAAC,IAAI,CAAClD,gBAAgB,CAACQ,IAAI;MACnC9C,YAAY,EAAE,IAAI,CAACA;IAAY,EAChC,CAAC;IAEF,IAAI,CAACgC,WAAW,CAAC1C,KAAK,IAAI5B,eAAe,CAACqC,MAAM,CAACkF,MAAM,CAAC,EAAE;MAKxDjD,WAAW,CAAC1C,KAAK,GAAG,IAAIpC,WAAW,CAAC;QAAEgI,aAAa,EAAEnF,MAAM,CAACkF;MAAM,CAAE,CAAC;;IAGvE,OAAOjD,WAAW;EACpB,CAAC;EAEOzD,aAAA,CAAAT,SAAA,CAAAiE,0BAA0B,GAAlC,UAAmChC,MAAgC;IAMjE,IACEA,MAAM,CAACqF,OAAO,IACd,IAAI,CAAC9C,gBAAgB,CAACmD,cAAc,IACpC,CAAC1F,MAAM,CAACX,OAAO,KACd,CAACW,MAAM,CAACV,IAAI,IAAIxB,MAAM,CAAC6H,IAAI,CAAC3F,MAAM,CAACV,IAAI,CAAC,CAACsG,MAAM,KAAK,CAAC,CAAC,IACvD,IAAI,CAAClD,UAAU,CAACxE,OAAO,CAAC8E,WAAW,KAAK,YAAY,EACpD;MACAlF,MAAM,CAAC2F,MAAM,CAACzD,MAAM,EAAE;QACpBX,OAAO,EAAE,IAAI;QACbG,aAAa,EAAEpC,aAAa,CAAC8G;OAC9B,CAAC;MACF,IAAI,CAACxB,UAAU,CAACwB,OAAO,EAAE;;EAE7B,CAAC;EACH,OAAA1F,aAAC;AAAD,CAAC,EA5gBD"},"metadata":{},"sourceType":"module","externalDependencies":[]}