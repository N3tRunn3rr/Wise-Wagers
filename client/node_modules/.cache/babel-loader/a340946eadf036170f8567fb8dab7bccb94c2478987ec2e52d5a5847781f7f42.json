{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/kenjifleming/course-challenges/Perfect-Parlay/perfect-parlay/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  var operations = [];\n  var depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n  var _iterator = _createForOfIteratorHelper(documentAST.definitions),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var definitionNode = _step.value;\n      switch (definitionNode.kind) {\n        case Kind.OPERATION_DEFINITION:\n          operations.push(definitionNode);\n          break;\n        case Kind.FRAGMENT_DEFINITION:\n          depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);\n          break;\n        default: // ignore non-executable definitions\n      }\n    } // For each operation, produce a new synthesized AST which includes only what\n    // is necessary for completing that operation.\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var separatedDocumentASTs = Object.create(null);\n  var _loop = function _loop() {\n    var operation = _operations[_i];\n    var dependencies = new Set();\n    var _iterator2 = _createForOfIteratorHelper(collectDependencies(operation.selectionSet)),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var fragmentName = _step2.value;\n        collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n      } // Provides the empty string for anonymous operations.\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    var operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(function (node) {\n        return node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value);\n      })\n    };\n  };\n  for (var _i = 0, _operations = operations; _i < _operations.length; _i++) {\n    _loop();\n  }\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    var immediateDeps = depGraph[fromName];\n    if (immediateDeps !== undefined) {\n      var _iterator3 = _createForOfIteratorHelper(immediateDeps),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var toName = _step3.value;\n          collectTransitiveDependencies(collected, depGraph, toName);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  }\n}\nfunction collectDependencies(selectionSet) {\n  var dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread: function FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    }\n  });\n  return dependencies;\n}","map":{"version":3,"names":["Kind","visit","separateOperations","documentAST","operations","depGraph","Object","create","_iterator","_createForOfIteratorHelper","definitions","_step","s","n","done","definitionNode","value","kind","OPERATION_DEFINITION","push","FRAGMENT_DEFINITION","name","collectDependencies","selectionSet","err","e","f","separatedDocumentASTs","_loop","operation","_operations","_i","dependencies","Set","_iterator2","_step2","fragmentName","collectTransitiveDependencies","operationName","DOCUMENT","filter","node","has","length","collected","fromName","add","immediateDeps","undefined","_iterator3","_step3","toName","FragmentSpread"],"sources":["/Users/kenjifleming/course-challenges/Perfect-Parlay/perfect-parlay/client/node_modules/graphql/utilities/separateOperations.mjs"],"sourcesContent":["import { Kind } from '../language/kinds.mjs';\nimport { visit } from '../language/visitor.mjs';\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\n\nexport function separateOperations(documentAST) {\n  const operations = [];\n  const depGraph = Object.create(null); // Populate metadata and build a dependency graph.\n\n  for (const definitionNode of documentAST.definitions) {\n    switch (definitionNode.kind) {\n      case Kind.OPERATION_DEFINITION:\n        operations.push(definitionNode);\n        break;\n\n      case Kind.FRAGMENT_DEFINITION:\n        depGraph[definitionNode.name.value] = collectDependencies(\n          definitionNode.selectionSet,\n        );\n        break;\n\n      default: // ignore non-executable definitions\n    }\n  } // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n\n  const separatedDocumentASTs = Object.create(null);\n\n  for (const operation of operations) {\n    const dependencies = new Set();\n\n    for (const fragmentName of collectDependencies(operation.selectionSet)) {\n      collectTransitiveDependencies(dependencies, depGraph, fragmentName);\n    } // Provides the empty string for anonymous operations.\n\n    const operationName = operation.name ? operation.name.value : ''; // The list of definition nodes to be included for this operation, sorted\n    // to retain the same order as the original document.\n\n    separatedDocumentASTs[operationName] = {\n      kind: Kind.DOCUMENT,\n      definitions: documentAST.definitions.filter(\n        (node) =>\n          node === operation ||\n          (node.kind === Kind.FRAGMENT_DEFINITION &&\n            dependencies.has(node.name.value)),\n      ),\n    };\n  }\n\n  return separatedDocumentASTs;\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(collected, depGraph, fromName) {\n  if (!collected.has(fromName)) {\n    collected.add(fromName);\n    const immediateDeps = depGraph[fromName];\n\n    if (immediateDeps !== undefined) {\n      for (const toName of immediateDeps) {\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    }\n  }\n}\n\nfunction collectDependencies(selectionSet) {\n  const dependencies = [];\n  visit(selectionSet, {\n    FragmentSpread(node) {\n      dependencies.push(node.name.value);\n    },\n  });\n  return dependencies;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}