{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/kenjifleming/course-challenges/Perfect-Parlay/perfect-parlay/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/Users/kenjifleming/course-challenges/Perfect-Parlay/perfect-parlay/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"/Users/kenjifleming/course-challenges/Perfect-Parlay/perfect-parlay/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/kenjifleming/course-challenges/Perfect-Parlay/perfect-parlay/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { inspect } from '../jsutils/inspect.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators.mjs';\nimport { isEnumType, isInputObjectType, isInputType, isInterfaceType, isNamedType, isNonNullType, isObjectType, isOutputType, isRequiredArgument, isRequiredInputField, isUnionType } from './definition.mjs';\nimport { GraphQLDeprecatedDirective, isDirective } from './directives.mjs';\nimport { isIntrospectionType } from './introspection.mjs';\nimport { assertSchema } from './schema.mjs';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n  var context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  var errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  var errors = validateSchema(schema);\n  if (errors.length !== 0) {\n    throw new Error(errors.map(function (error) {\n      return error.message;\n    }).join('\\n\\n'));\n  }\n}\nvar SchemaValidationContext = /*#__PURE__*/function () {\n  function SchemaValidationContext(schema) {\n    _classCallCheck(this, SchemaValidationContext);\n    this._errors = [];\n    this.schema = schema;\n  }\n  _createClass(SchemaValidationContext, [{\n    key: \"reportError\",\n    value: function reportError(message, nodes) {\n      var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n      this._errors.push(new GraphQLError(message, {\n        nodes: _nodes\n      }));\n    }\n  }, {\n    key: \"getErrors\",\n    value: function getErrors() {\n      return this._errors;\n    }\n  }]);\n  return SchemaValidationContext;\n}();\nfunction validateRootTypes(context) {\n  var schema = context.schema;\n  var queryType = schema.getQueryType();\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n    context.reportError(\"Query root type must be Object type, it cannot be \".concat(inspect(queryType), \".\"), (_getOperationTypeNode = getOperationTypeNode(schema, OperationTypeNode.QUERY)) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);\n  }\n  var mutationType = schema.getMutationType();\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n    context.reportError('Mutation root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(mutationType), \".\"), (_getOperationTypeNode2 = getOperationTypeNode(schema, OperationTypeNode.MUTATION)) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);\n  }\n  var subscriptionType = schema.getSubscriptionType();\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n    context.reportError('Subscription root type must be Object type if provided, it cannot be ' + \"\".concat(inspect(subscriptionType), \".\"), (_getOperationTypeNode3 = getOperationTypeNode(schema, OperationTypeNode.SUBSCRIPTION)) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);\n  }\n}\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find;\n  return (_flatMap$find = [schema.astNode].concat(_toConsumableArray(schema.extensionASTNodes)).flatMap(\n  // FIXME: https://github.com/graphql/graphql-js/issues/2203\n  function (schemaNode) {\n    var _schemaNode$operation;\n    return (/* c8 ignore next */\n      (_schemaNode$operation = schemaNode === null || schemaNode === void 0 ? void 0 : schemaNode.operationTypes) !== null && _schemaNode$operation !== void 0 ? _schemaNode$operation : []\n    );\n  }).find(function (operationNode) {\n    return operationNode.operation === operation;\n  })) === null || _flatMap$find === void 0 ? void 0 : _flatMap$find.type;\n}\nfunction validateDirectives(context) {\n  var _iterator = _createForOfIteratorHelper(context.schema.getDirectives()),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var directive = _step.value;\n      // Ensure all directives are in fact GraphQL directives.\n      if (!isDirective(directive)) {\n        context.reportError(\"Expected directive but got: \".concat(inspect(directive), \".\"), directive === null || directive === void 0 ? void 0 : directive.astNode);\n        continue;\n      } // Ensure they are named correctly.\n\n      validateName(context, directive); // TODO: Ensure proper locations.\n      // Ensure the arguments are valid.\n      var _iterator2 = _createForOfIteratorHelper(directive.args),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var arg = _step2.value;\n          // Ensure they are named correctly.\n          validateName(context, arg); // Ensure the type is an input type.\n\n          if (!isInputType(arg.type)) {\n            context.reportError(\"The type of @\".concat(directive.name, \"(\").concat(arg.name, \":) must be Input Type \") + \"but got: \".concat(inspect(arg.type), \".\"), arg.astNode);\n          }\n          if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n            var _arg$astNode;\n            context.reportError(\"Required argument @\".concat(directive.name, \"(\").concat(arg.name, \":) cannot be deprecated.\"), [getDeprecatedDirectiveNode(arg.astNode), (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type]);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(\"Name \\\"\".concat(node.name, \"\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\"), node.astNode);\n  }\n}\nfunction validateTypes(context) {\n  var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);\n  var typeMap = context.schema.getTypeMap();\n  for (var _i = 0, _Object$values = Object.values(typeMap); _i < _Object$values.length; _i++) {\n    var type = _Object$values[_i];\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\"Expected GraphQL named type but got: \".concat(inspect(type), \".\"), type.astNode);\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\nfunction validateFields(context, type) {\n  var fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(\"Type \".concat(type.name, \" must define one or more fields.\"), [type.astNode].concat(_toConsumableArray(type.extensionASTNodes)));\n  }\n  for (var _i2 = 0, _fields = fields; _i2 < _fields.length; _i2++) {\n    var field = _fields[_i2];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n      context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \" must be Output Type \") + \"but got: \".concat(inspect(field.type), \".\"), (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);\n    } // Ensure the arguments are valid\n    var _iterator3 = _createForOfIteratorHelper(field.args),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var arg = _step3.value;\n        var argName = arg.name; // Ensure they are named correctly.\n\n        validateName(context, arg); // Ensure the type is an input type\n\n        if (!isInputType(arg.type)) {\n          var _arg$astNode2;\n          context.reportError(\"The type of \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) must be Input \") + \"Type but got: \".concat(inspect(arg.type), \".\"), (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);\n        }\n        if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n          var _arg$astNode3;\n          context.reportError(\"Required argument \".concat(type.name, \".\").concat(field.name, \"(\").concat(argName, \":) cannot be deprecated.\"), [getDeprecatedDirectiveNode(arg.astNode), (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type]);\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n}\nfunction validateInterfaces(context, type) {\n  var ifaceTypeNames = Object.create(null);\n  var _iterator4 = _createForOfIteratorHelper(type.getInterfaces()),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var iface = _step4.value;\n      if (!isInterfaceType(iface)) {\n        context.reportError(\"Type \".concat(inspect(type), \" must only implement Interface types, \") + \"it cannot implement \".concat(inspect(iface), \".\"), getAllImplementsInterfaceNodes(type, iface));\n        continue;\n      }\n      if (type === iface) {\n        context.reportError(\"Type \".concat(type.name, \" cannot implement itself because it would create a circular reference.\"), getAllImplementsInterfaceNodes(type, iface));\n        continue;\n      }\n      if (ifaceTypeNames[iface.name]) {\n        context.reportError(\"Type \".concat(type.name, \" can only implement \").concat(iface.name, \" once.\"), getAllImplementsInterfaceNodes(type, iface));\n        continue;\n      }\n      ifaceTypeNames[iface.name] = true;\n      validateTypeImplementsAncestors(context, type, iface);\n      validateTypeImplementsInterface(context, type, iface);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n}\nfunction validateTypeImplementsInterface(context, type, iface) {\n  var typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (var _i3 = 0, _Object$values2 = Object.values(iface.getFields()); _i3 < _Object$values2.length; _i3++) {\n    var ifaceField = _Object$values2[_i3];\n    var fieldName = ifaceField.name;\n    var typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expected but \").concat(type.name, \" does not provide it.\"), [ifaceField.astNode, type.astNode].concat(_toConsumableArray(type.extensionASTNodes)));\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n      context.reportError(\"Interface field \".concat(iface.name, \".\").concat(fieldName, \" expects type \") + \"\".concat(inspect(ifaceField.type), \" but \").concat(type.name, \".\").concat(fieldName, \" \") + \"is type \".concat(inspect(typeField.type), \".\"), [(_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type, (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type]);\n    } // Assert each interface field arg is implemented.\n    var _iterator5 = _createForOfIteratorHelper(ifaceField.args),\n      _step5;\n    try {\n      var _loop = function _loop() {\n        var ifaceArg = _step5.value;\n        var argName = ifaceArg.name;\n        var typeArg = typeField.args.find(function (arg) {\n          return arg.name === argName;\n        }); // Assert interface field arg exists on object field.\n\n        if (!typeArg) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) expected but \").concat(type.name, \".\").concat(fieldName, \" does not provide it.\"), [ifaceArg.astNode, typeField.astNode]);\n          return \"continue\";\n        } // Assert interface field arg type matches object field arg type.\n        // (invariant)\n        // TODO: change to contravariant?\n\n        if (!isEqualType(ifaceArg.type, typeArg.type)) {\n          context.reportError(\"Interface field argument \".concat(iface.name, \".\").concat(fieldName, \"(\").concat(argName, \":) \") + \"expects type \".concat(inspect(ifaceArg.type), \" but \") + \"\".concat(type.name, \".\").concat(fieldName, \"(\").concat(argName, \":) is type \") + \"\".concat(inspect(typeArg.type), \".\"), [(_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type, (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type]);\n        } // TODO: validate default values?\n      };\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n        var _ret = _loop();\n        if (_ret === \"continue\") continue;\n      } // Assert additional arguments must not be required.\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n    var _iterator6 = _createForOfIteratorHelper(typeField.args),\n      _step6;\n    try {\n      var _loop2 = function _loop2() {\n        var typeArg = _step6.value;\n        var argName = typeArg.name;\n        var ifaceArg = ifaceField.args.find(function (arg) {\n          return arg.name === argName;\n        });\n        if (!ifaceArg && isRequiredArgument(typeArg)) {\n          context.reportError(\"Object field \".concat(type.name, \".\").concat(fieldName, \" includes required argument \").concat(argName, \" that is missing from the Interface field \").concat(iface.name, \".\").concat(fieldName, \".\"), [typeArg.astNode, ifaceField.astNode]);\n        }\n      };\n      for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n        _loop2();\n      }\n    } catch (err) {\n      _iterator6.e(err);\n    } finally {\n      _iterator6.f();\n    }\n  }\n}\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  var ifaceInterfaces = type.getInterfaces();\n  var _iterator7 = _createForOfIteratorHelper(iface.getInterfaces()),\n    _step7;\n  try {\n    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n      var transitive = _step7.value;\n      if (!ifaceInterfaces.includes(transitive)) {\n        context.reportError(transitive === type ? \"Type \".concat(type.name, \" cannot implement \").concat(iface.name, \" because it would create a circular reference.\") : \"Type \".concat(type.name, \" must implement \").concat(transitive.name, \" because it is implemented by \").concat(iface.name, \".\"), [].concat(_toConsumableArray(getAllImplementsInterfaceNodes(iface, transitive)), _toConsumableArray(getAllImplementsInterfaceNodes(type, iface))));\n      }\n    }\n  } catch (err) {\n    _iterator7.e(err);\n  } finally {\n    _iterator7.f();\n  }\n}\nfunction validateUnionMembers(context, union) {\n  var memberTypes = union.getTypes();\n  if (memberTypes.length === 0) {\n    context.reportError(\"Union type \".concat(union.name, \" must define one or more member types.\"), [union.astNode].concat(_toConsumableArray(union.extensionASTNodes)));\n  }\n  var includedTypeNames = Object.create(null);\n  var _iterator8 = _createForOfIteratorHelper(memberTypes),\n    _step8;\n  try {\n    for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n      var memberType = _step8.value;\n      if (includedTypeNames[memberType.name]) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include type \").concat(memberType.name, \" once.\"), getUnionMemberTypeNodes(union, memberType.name));\n        continue;\n      }\n      includedTypeNames[memberType.name] = true;\n      if (!isObjectType(memberType)) {\n        context.reportError(\"Union type \".concat(union.name, \" can only include Object types, \") + \"it cannot include \".concat(inspect(memberType), \".\"), getUnionMemberTypeNodes(union, String(memberType)));\n      }\n    }\n  } catch (err) {\n    _iterator8.e(err);\n  } finally {\n    _iterator8.f();\n  }\n}\nfunction validateEnumValues(context, enumType) {\n  var enumValues = enumType.getValues();\n  if (enumValues.length === 0) {\n    context.reportError(\"Enum type \".concat(enumType.name, \" must define one or more values.\"), [enumType.astNode].concat(_toConsumableArray(enumType.extensionASTNodes)));\n  }\n  var _iterator9 = _createForOfIteratorHelper(enumValues),\n    _step9;\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var enumValue = _step9.value;\n      // Ensure valid name.\n      validateName(context, enumValue);\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n}\nfunction validateInputFields(context, inputObj) {\n  var fields = Object.values(inputObj.getFields());\n  if (fields.length === 0) {\n    context.reportError(\"Input Object type \".concat(inputObj.name, \" must define one or more fields.\"), [inputObj.astNode].concat(_toConsumableArray(inputObj.extensionASTNodes)));\n  } // Ensure the arguments are valid\n\n  for (var _i4 = 0, _fields2 = fields; _i4 < _fields2.length; _i4++) {\n    var field = _fields2[_i4];\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n      context.reportError(\"The type of \".concat(inputObj.name, \".\").concat(field.name, \" must be Input Type \") + \"but got: \".concat(inspect(field.type), \".\"), (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);\n    }\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n      context.reportError(\"Required input field \".concat(inputObj.name, \".\").concat(field.name, \" cannot be deprecated.\"), [getDeprecatedDirectiveNode(field.astNode), (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type]);\n    }\n  }\n}\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  var visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  var fieldPath = []; // Position in the type path\n\n  var fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    var fields = Object.values(inputObj.getFields());\n    for (var _i5 = 0, _fields3 = fields; _i5 < _fields3.length; _i5++) {\n      var field = _fields3[_i5];\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        var fieldType = field.type.ofType;\n        var cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          var cyclePath = fieldPath.slice(cycleIndex);\n          var pathStr = cyclePath.map(function (fieldObj) {\n            return fieldObj.name;\n          }).join('.');\n          context.reportError(\"Cannot reference Input Object \\\"\".concat(fieldType.name, \"\\\" within itself through a series of non-null fields: \\\"\").concat(pathStr, \"\\\".\"), cyclePath.map(function (fieldObj) {\n            return fieldObj.astNode;\n          }));\n        }\n        fieldPath.pop();\n      }\n    }\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  var astNode = type.astNode,\n    extensionASTNodes = type.extensionASTNodes;\n  var nodes = astNode != null ? [astNode].concat(_toConsumableArray(extensionASTNodes)) : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes.flatMap(function (typeNode) {\n    var _typeNode$interfaces;\n    return (/* c8 ignore next */\n      (_typeNode$interfaces = typeNode.interfaces) !== null && _typeNode$interfaces !== void 0 ? _typeNode$interfaces : []\n    );\n  }).filter(function (ifaceNode) {\n    return ifaceNode.name.value === iface.name;\n  });\n}\nfunction getUnionMemberTypeNodes(union, typeName) {\n  var astNode = union.astNode,\n    extensionASTNodes = union.extensionASTNodes;\n  var nodes = astNode != null ? [astNode].concat(_toConsumableArray(extensionASTNodes)) : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes.flatMap(function (unionNode) {\n    var _unionNode$types;\n    return (/* c8 ignore next */\n      (_unionNode$types = unionNode.types) !== null && _unionNode$types !== void 0 ? _unionNode$types : []\n    );\n  }).filter(function (typeNode) {\n    return typeNode.name.value === typeName;\n  });\n}\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(function (node) {\n    return node.name.value === GraphQLDeprecatedDirective.name;\n  });\n}","map":{"version":3,"names":["inspect","GraphQLError","OperationTypeNode","isEqualType","isTypeSubTypeOf","isEnumType","isInputObjectType","isInputType","isInterfaceType","isNamedType","isNonNullType","isObjectType","isOutputType","isRequiredArgument","isRequiredInputField","isUnionType","GraphQLDeprecatedDirective","isDirective","isIntrospectionType","assertSchema","validateSchema","schema","__validationErrors","context","SchemaValidationContext","validateRootTypes","validateDirectives","validateTypes","errors","getErrors","assertValidSchema","length","Error","map","error","message","join","_classCallCheck","_errors","_createClass","key","value","reportError","nodes","_nodes","Array","isArray","filter","Boolean","push","queryType","getQueryType","astNode","_getOperationTypeNode","concat","getOperationTypeNode","QUERY","mutationType","getMutationType","_getOperationTypeNode2","MUTATION","subscriptionType","getSubscriptionType","_getOperationTypeNode3","SUBSCRIPTION","operation","_flatMap$find","_toConsumableArray","extensionASTNodes","flatMap","schemaNode","_schemaNode$operation","operationTypes","find","operationNode","type","_iterator","_createForOfIteratorHelper","getDirectives","_step","s","n","done","directive","validateName","_iterator2","args","_step2","arg","name","deprecationReason","_arg$astNode","getDeprecatedDirectiveNode","err","e","f","node","startsWith","validateInputObjectCircularRefs","createInputObjectCircularRefsValidator","typeMap","getTypeMap","_i","_Object$values","Object","values","validateFields","validateInterfaces","validateUnionMembers","validateEnumValues","validateInputFields","fields","getFields","_i2","_fields","field","_field$astNode","_iterator3","_step3","argName","_arg$astNode2","_arg$astNode3","ifaceTypeNames","create","_iterator4","getInterfaces","_step4","iface","getAllImplementsInterfaceNodes","validateTypeImplementsAncestors","validateTypeImplementsInterface","typeFieldMap","_i3","_Object$values2","ifaceField","fieldName","typeField","_ifaceField$astNode","_typeField$astNode","_iterator5","_step5","_loop","ifaceArg","typeArg","_ifaceArg$astNode","_typeArg$astNode","_ret","_iterator6","_step6","_loop2","ifaceInterfaces","_iterator7","_step7","transitive","includes","union","memberTypes","getTypes","includedTypeNames","_iterator8","_step8","memberType","getUnionMemberTypeNodes","String","enumType","enumValues","getValues","_iterator9","_step9","enumValue","inputObj","_i4","_fields2","_field$astNode2","_field$astNode3","visitedTypes","fieldPath","fieldPathIndexByTypeName","detectCycleRecursive","_i5","_fields3","ofType","fieldType","cycleIndex","undefined","cyclePath","slice","pathStr","fieldObj","pop","typeNode","_typeNode$interfaces","interfaces","ifaceNode","typeName","unionNode","_unionNode$types","types","definitionNode","_definitionNode$direc","directives"],"sources":["/Users/kenjifleming/course-challenges/Perfect-Parlay/perfect-parlay/client/node_modules/graphql/type/validate.mjs"],"sourcesContent":["import { inspect } from '../jsutils/inspect.mjs';\nimport { GraphQLError } from '../error/GraphQLError.mjs';\nimport { OperationTypeNode } from '../language/ast.mjs';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators.mjs';\nimport {\n  isEnumType,\n  isInputObjectType,\n  isInputType,\n  isInterfaceType,\n  isNamedType,\n  isNonNullType,\n  isObjectType,\n  isOutputType,\n  isRequiredArgument,\n  isRequiredInputField,\n  isUnionType,\n} from './definition.mjs';\nimport { GraphQLDeprecatedDirective, isDirective } from './directives.mjs';\nimport { isIntrospectionType } from './introspection.mjs';\nimport { assertSchema } from './schema.mjs';\n/**\n * Implements the \"Type Validation\" sub-sections of the specification's\n * \"Type System\" section.\n *\n * Validation runs synchronously, returning an array of encountered errors, or\n * an empty array if no errors were encountered and the Schema is valid.\n */\n\nexport function validateSchema(schema) {\n  // First check to ensure the provided value is in fact a GraphQLSchema.\n  assertSchema(schema); // If this Schema has already been validated, return the previous results.\n\n  if (schema.__validationErrors) {\n    return schema.__validationErrors;\n  } // Validate the schema, producing a list of errors.\n\n  const context = new SchemaValidationContext(schema);\n  validateRootTypes(context);\n  validateDirectives(context);\n  validateTypes(context); // Persist the results of validation before returning to ensure validation\n  // does not run multiple times for this schema.\n\n  const errors = context.getErrors();\n  schema.__validationErrors = errors;\n  return errors;\n}\n/**\n * Utility function which asserts a schema is valid by throwing an error if\n * it is invalid.\n */\n\nexport function assertValidSchema(schema) {\n  const errors = validateSchema(schema);\n\n  if (errors.length !== 0) {\n    throw new Error(errors.map((error) => error.message).join('\\n\\n'));\n  }\n}\n\nclass SchemaValidationContext {\n  constructor(schema) {\n    this._errors = [];\n    this.schema = schema;\n  }\n\n  reportError(message, nodes) {\n    const _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;\n\n    this._errors.push(\n      new GraphQLError(message, {\n        nodes: _nodes,\n      }),\n    );\n  }\n\n  getErrors() {\n    return this._errors;\n  }\n}\n\nfunction validateRootTypes(context) {\n  const schema = context.schema;\n  const queryType = schema.getQueryType();\n\n  if (!queryType) {\n    context.reportError('Query root type must be provided.', schema.astNode);\n  } else if (!isObjectType(queryType)) {\n    var _getOperationTypeNode;\n\n    context.reportError(\n      `Query root type must be Object type, it cannot be ${inspect(\n        queryType,\n      )}.`,\n      (_getOperationTypeNode = getOperationTypeNode(\n        schema,\n        OperationTypeNode.QUERY,\n      )) !== null && _getOperationTypeNode !== void 0\n        ? _getOperationTypeNode\n        : queryType.astNode,\n    );\n  }\n\n  const mutationType = schema.getMutationType();\n\n  if (mutationType && !isObjectType(mutationType)) {\n    var _getOperationTypeNode2;\n\n    context.reportError(\n      'Mutation root type must be Object type if provided, it cannot be ' +\n        `${inspect(mutationType)}.`,\n      (_getOperationTypeNode2 = getOperationTypeNode(\n        schema,\n        OperationTypeNode.MUTATION,\n      )) !== null && _getOperationTypeNode2 !== void 0\n        ? _getOperationTypeNode2\n        : mutationType.astNode,\n    );\n  }\n\n  const subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType && !isObjectType(subscriptionType)) {\n    var _getOperationTypeNode3;\n\n    context.reportError(\n      'Subscription root type must be Object type if provided, it cannot be ' +\n        `${inspect(subscriptionType)}.`,\n      (_getOperationTypeNode3 = getOperationTypeNode(\n        schema,\n        OperationTypeNode.SUBSCRIPTION,\n      )) !== null && _getOperationTypeNode3 !== void 0\n        ? _getOperationTypeNode3\n        : subscriptionType.astNode,\n    );\n  }\n}\n\nfunction getOperationTypeNode(schema, operation) {\n  var _flatMap$find;\n\n  return (_flatMap$find = [schema.astNode, ...schema.extensionASTNodes]\n    .flatMap(\n      // FIXME: https://github.com/graphql/graphql-js/issues/2203\n      (schemaNode) => {\n        var _schemaNode$operation;\n\n        return (\n          /* c8 ignore next */\n          (_schemaNode$operation =\n            schemaNode === null || schemaNode === void 0\n              ? void 0\n              : schemaNode.operationTypes) !== null &&\n            _schemaNode$operation !== void 0\n            ? _schemaNode$operation\n            : []\n        );\n      },\n    )\n    .find((operationNode) => operationNode.operation === operation)) === null ||\n    _flatMap$find === void 0\n    ? void 0\n    : _flatMap$find.type;\n}\n\nfunction validateDirectives(context) {\n  for (const directive of context.schema.getDirectives()) {\n    // Ensure all directives are in fact GraphQL directives.\n    if (!isDirective(directive)) {\n      context.reportError(\n        `Expected directive but got: ${inspect(directive)}.`,\n        directive === null || directive === void 0 ? void 0 : directive.astNode,\n      );\n      continue;\n    } // Ensure they are named correctly.\n\n    validateName(context, directive); // TODO: Ensure proper locations.\n    // Ensure the arguments are valid.\n\n    for (const arg of directive.args) {\n      // Ensure they are named correctly.\n      validateName(context, arg); // Ensure the type is an input type.\n\n      if (!isInputType(arg.type)) {\n        context.reportError(\n          `The type of @${directive.name}(${arg.name}:) must be Input Type ` +\n            `but got: ${inspect(arg.type)}.`,\n          arg.astNode,\n        );\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode;\n\n        context.reportError(\n          `Required argument @${directive.name}(${arg.name}:) cannot be deprecated.`,\n          [\n            getDeprecatedDirectiveNode(arg.astNode),\n            (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0\n              ? void 0\n              : _arg$astNode.type,\n          ],\n        );\n      }\n    }\n  }\n}\n\nfunction validateName(context, node) {\n  // Ensure names are valid, however introspection types opt out.\n  if (node.name.startsWith('__')) {\n    context.reportError(\n      `Name \"${node.name}\" must not begin with \"__\", which is reserved by GraphQL introspection.`,\n      node.astNode,\n    );\n  }\n}\n\nfunction validateTypes(context) {\n  const validateInputObjectCircularRefs =\n    createInputObjectCircularRefsValidator(context);\n  const typeMap = context.schema.getTypeMap();\n\n  for (const type of Object.values(typeMap)) {\n    // Ensure all provided types are in fact GraphQL type.\n    if (!isNamedType(type)) {\n      context.reportError(\n        `Expected GraphQL named type but got: ${inspect(type)}.`,\n        type.astNode,\n      );\n      continue;\n    } // Ensure it is named correctly (excluding introspection types).\n\n    if (!isIntrospectionType(type)) {\n      validateName(context, type);\n    }\n\n    if (isObjectType(type)) {\n      // Ensure fields are valid\n      validateFields(context, type); // Ensure objects implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isInterfaceType(type)) {\n      // Ensure fields are valid.\n      validateFields(context, type); // Ensure interfaces implement the interfaces they claim to.\n\n      validateInterfaces(context, type);\n    } else if (isUnionType(type)) {\n      // Ensure Unions include valid member types.\n      validateUnionMembers(context, type);\n    } else if (isEnumType(type)) {\n      // Ensure Enums have valid values.\n      validateEnumValues(context, type);\n    } else if (isInputObjectType(type)) {\n      // Ensure Input Object fields are valid.\n      validateInputFields(context, type); // Ensure Input Objects do not contain non-nullable circular references\n\n      validateInputObjectCircularRefs(type);\n    }\n  }\n}\n\nfunction validateFields(context, type) {\n  const fields = Object.values(type.getFields()); // Objects and Interfaces both must define one or more fields.\n\n  if (fields.length === 0) {\n    context.reportError(`Type ${type.name} must define one or more fields.`, [\n      type.astNode,\n      ...type.extensionASTNodes,\n    ]);\n  }\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an output type\n\n    if (!isOutputType(field.type)) {\n      var _field$astNode;\n\n      context.reportError(\n        `The type of ${type.name}.${field.name} must be Output Type ` +\n          `but got: ${inspect(field.type)}.`,\n        (_field$astNode = field.astNode) === null || _field$astNode === void 0\n          ? void 0\n          : _field$astNode.type,\n      );\n    } // Ensure the arguments are valid\n\n    for (const arg of field.args) {\n      const argName = arg.name; // Ensure they are named correctly.\n\n      validateName(context, arg); // Ensure the type is an input type\n\n      if (!isInputType(arg.type)) {\n        var _arg$astNode2;\n\n        context.reportError(\n          `The type of ${type.name}.${field.name}(${argName}:) must be Input ` +\n            `Type but got: ${inspect(arg.type)}.`,\n          (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0\n            ? void 0\n            : _arg$astNode2.type,\n        );\n      }\n\n      if (isRequiredArgument(arg) && arg.deprecationReason != null) {\n        var _arg$astNode3;\n\n        context.reportError(\n          `Required argument ${type.name}.${field.name}(${argName}:) cannot be deprecated.`,\n          [\n            getDeprecatedDirectiveNode(arg.astNode),\n            (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0\n              ? void 0\n              : _arg$astNode3.type,\n          ],\n        );\n      }\n    }\n  }\n}\n\nfunction validateInterfaces(context, type) {\n  const ifaceTypeNames = Object.create(null);\n\n  for (const iface of type.getInterfaces()) {\n    if (!isInterfaceType(iface)) {\n      context.reportError(\n        `Type ${inspect(type)} must only implement Interface types, ` +\n          `it cannot implement ${inspect(iface)}.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (type === iface) {\n      context.reportError(\n        `Type ${type.name} cannot implement itself because it would create a circular reference.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    if (ifaceTypeNames[iface.name]) {\n      context.reportError(\n        `Type ${type.name} can only implement ${iface.name} once.`,\n        getAllImplementsInterfaceNodes(type, iface),\n      );\n      continue;\n    }\n\n    ifaceTypeNames[iface.name] = true;\n    validateTypeImplementsAncestors(context, type, iface);\n    validateTypeImplementsInterface(context, type, iface);\n  }\n}\n\nfunction validateTypeImplementsInterface(context, type, iface) {\n  const typeFieldMap = type.getFields(); // Assert each interface field is implemented.\n\n  for (const ifaceField of Object.values(iface.getFields())) {\n    const fieldName = ifaceField.name;\n    const typeField = typeFieldMap[fieldName]; // Assert interface field exists on type.\n\n    if (!typeField) {\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expected but ${type.name} does not provide it.`,\n        [ifaceField.astNode, type.astNode, ...type.extensionASTNodes],\n      );\n      continue;\n    } // Assert interface field type is satisfied by type field type, by being\n    // a valid subtype. (covariant)\n\n    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {\n      var _ifaceField$astNode, _typeField$astNode;\n\n      context.reportError(\n        `Interface field ${iface.name}.${fieldName} expects type ` +\n          `${inspect(ifaceField.type)} but ${type.name}.${fieldName} ` +\n          `is type ${inspect(typeField.type)}.`,\n        [\n          (_ifaceField$astNode = ifaceField.astNode) === null ||\n          _ifaceField$astNode === void 0\n            ? void 0\n            : _ifaceField$astNode.type,\n          (_typeField$astNode = typeField.astNode) === null ||\n          _typeField$astNode === void 0\n            ? void 0\n            : _typeField$astNode.type,\n        ],\n      );\n    } // Assert each interface field arg is implemented.\n\n    for (const ifaceArg of ifaceField.args) {\n      const argName = ifaceArg.name;\n      const typeArg = typeField.args.find((arg) => arg.name === argName); // Assert interface field arg exists on object field.\n\n      if (!typeArg) {\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) expected but ${type.name}.${fieldName} does not provide it.`,\n          [ifaceArg.astNode, typeField.astNode],\n        );\n        continue;\n      } // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      // TODO: change to contravariant?\n\n      if (!isEqualType(ifaceArg.type, typeArg.type)) {\n        var _ifaceArg$astNode, _typeArg$astNode;\n\n        context.reportError(\n          `Interface field argument ${iface.name}.${fieldName}(${argName}:) ` +\n            `expects type ${inspect(ifaceArg.type)} but ` +\n            `${type.name}.${fieldName}(${argName}:) is type ` +\n            `${inspect(typeArg.type)}.`,\n          [\n            (_ifaceArg$astNode = ifaceArg.astNode) === null ||\n            _ifaceArg$astNode === void 0\n              ? void 0\n              : _ifaceArg$astNode.type,\n            (_typeArg$astNode = typeArg.astNode) === null ||\n            _typeArg$astNode === void 0\n              ? void 0\n              : _typeArg$astNode.type,\n          ],\n        );\n      } // TODO: validate default values?\n    } // Assert additional arguments must not be required.\n\n    for (const typeArg of typeField.args) {\n      const argName = typeArg.name;\n      const ifaceArg = ifaceField.args.find((arg) => arg.name === argName);\n\n      if (!ifaceArg && isRequiredArgument(typeArg)) {\n        context.reportError(\n          `Object field ${type.name}.${fieldName} includes required argument ${argName} that is missing from the Interface field ${iface.name}.${fieldName}.`,\n          [typeArg.astNode, ifaceField.astNode],\n        );\n      }\n    }\n  }\n}\n\nfunction validateTypeImplementsAncestors(context, type, iface) {\n  const ifaceInterfaces = type.getInterfaces();\n\n  for (const transitive of iface.getInterfaces()) {\n    if (!ifaceInterfaces.includes(transitive)) {\n      context.reportError(\n        transitive === type\n          ? `Type ${type.name} cannot implement ${iface.name} because it would create a circular reference.`\n          : `Type ${type.name} must implement ${transitive.name} because it is implemented by ${iface.name}.`,\n        [\n          ...getAllImplementsInterfaceNodes(iface, transitive),\n          ...getAllImplementsInterfaceNodes(type, iface),\n        ],\n      );\n    }\n  }\n}\n\nfunction validateUnionMembers(context, union) {\n  const memberTypes = union.getTypes();\n\n  if (memberTypes.length === 0) {\n    context.reportError(\n      `Union type ${union.name} must define one or more member types.`,\n      [union.astNode, ...union.extensionASTNodes],\n    );\n  }\n\n  const includedTypeNames = Object.create(null);\n\n  for (const memberType of memberTypes) {\n    if (includedTypeNames[memberType.name]) {\n      context.reportError(\n        `Union type ${union.name} can only include type ${memberType.name} once.`,\n        getUnionMemberTypeNodes(union, memberType.name),\n      );\n      continue;\n    }\n\n    includedTypeNames[memberType.name] = true;\n\n    if (!isObjectType(memberType)) {\n      context.reportError(\n        `Union type ${union.name} can only include Object types, ` +\n          `it cannot include ${inspect(memberType)}.`,\n        getUnionMemberTypeNodes(union, String(memberType)),\n      );\n    }\n  }\n}\n\nfunction validateEnumValues(context, enumType) {\n  const enumValues = enumType.getValues();\n\n  if (enumValues.length === 0) {\n    context.reportError(\n      `Enum type ${enumType.name} must define one or more values.`,\n      [enumType.astNode, ...enumType.extensionASTNodes],\n    );\n  }\n\n  for (const enumValue of enumValues) {\n    // Ensure valid name.\n    validateName(context, enumValue);\n  }\n}\n\nfunction validateInputFields(context, inputObj) {\n  const fields = Object.values(inputObj.getFields());\n\n  if (fields.length === 0) {\n    context.reportError(\n      `Input Object type ${inputObj.name} must define one or more fields.`,\n      [inputObj.astNode, ...inputObj.extensionASTNodes],\n    );\n  } // Ensure the arguments are valid\n\n  for (const field of fields) {\n    // Ensure they are named correctly.\n    validateName(context, field); // Ensure the type is an input type\n\n    if (!isInputType(field.type)) {\n      var _field$astNode2;\n\n      context.reportError(\n        `The type of ${inputObj.name}.${field.name} must be Input Type ` +\n          `but got: ${inspect(field.type)}.`,\n        (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0\n          ? void 0\n          : _field$astNode2.type,\n      );\n    }\n\n    if (isRequiredInputField(field) && field.deprecationReason != null) {\n      var _field$astNode3;\n\n      context.reportError(\n        `Required input field ${inputObj.name}.${field.name} cannot be deprecated.`,\n        [\n          getDeprecatedDirectiveNode(field.astNode),\n          (_field$astNode3 = field.astNode) === null ||\n          _field$astNode3 === void 0\n            ? void 0\n            : _field$astNode3.type,\n        ],\n      );\n    }\n  }\n}\n\nfunction createInputObjectCircularRefsValidator(context) {\n  // Modified copy of algorithm from 'src/validation/rules/NoFragmentCycles.js'.\n  // Tracks already visited types to maintain O(N) and to ensure that cycles\n  // are not redundantly reported.\n  const visitedTypes = Object.create(null); // Array of types nodes used to produce meaningful errors\n\n  const fieldPath = []; // Position in the type path\n\n  const fieldPathIndexByTypeName = Object.create(null);\n  return detectCycleRecursive; // This does a straight-forward DFS to find cycles.\n  // It does not terminate when a cycle was found but continues to explore\n  // the graph to find all possible cycles.\n\n  function detectCycleRecursive(inputObj) {\n    if (visitedTypes[inputObj.name]) {\n      return;\n    }\n\n    visitedTypes[inputObj.name] = true;\n    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;\n    const fields = Object.values(inputObj.getFields());\n\n    for (const field of fields) {\n      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {\n        const fieldType = field.type.ofType;\n        const cycleIndex = fieldPathIndexByTypeName[fieldType.name];\n        fieldPath.push(field);\n\n        if (cycleIndex === undefined) {\n          detectCycleRecursive(fieldType);\n        } else {\n          const cyclePath = fieldPath.slice(cycleIndex);\n          const pathStr = cyclePath.map((fieldObj) => fieldObj.name).join('.');\n          context.reportError(\n            `Cannot reference Input Object \"${fieldType.name}\" within itself through a series of non-null fields: \"${pathStr}\".`,\n            cyclePath.map((fieldObj) => fieldObj.astNode),\n          );\n        }\n\n        fieldPath.pop();\n      }\n    }\n\n    fieldPathIndexByTypeName[inputObj.name] = undefined;\n  }\n}\n\nfunction getAllImplementsInterfaceNodes(type, iface) {\n  const { astNode, extensionASTNodes } = type;\n  const nodes =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes\n    .flatMap((typeNode) => {\n      var _typeNode$interfaces;\n\n      return (\n        /* c8 ignore next */\n        (_typeNode$interfaces = typeNode.interfaces) !== null &&\n          _typeNode$interfaces !== void 0\n          ? _typeNode$interfaces\n          : []\n      );\n    })\n    .filter((ifaceNode) => ifaceNode.name.value === iface.name);\n}\n\nfunction getUnionMemberTypeNodes(union, typeName) {\n  const { astNode, extensionASTNodes } = union;\n  const nodes =\n    astNode != null ? [astNode, ...extensionASTNodes] : extensionASTNodes; // FIXME: https://github.com/graphql/graphql-js/issues/2203\n\n  return nodes\n    .flatMap((unionNode) => {\n      var _unionNode$types;\n\n      return (\n        /* c8 ignore next */\n        (_unionNode$types = unionNode.types) !== null &&\n          _unionNode$types !== void 0\n          ? _unionNode$types\n          : []\n      );\n    })\n    .filter((typeNode) => typeNode.name.value === typeName);\n}\n\nfunction getDeprecatedDirectiveNode(definitionNode) {\n  var _definitionNode$direc;\n\n  return definitionNode === null || definitionNode === void 0\n    ? void 0\n    : (_definitionNode$direc = definitionNode.directives) === null ||\n      _definitionNode$direc === void 0\n    ? void 0\n    : _definitionNode$direc.find(\n        (node) => node.name.value === GraphQLDeprecatedDirective.name,\n      );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}