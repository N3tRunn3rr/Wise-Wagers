{"ast":null,"code":"// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nvar currentContext = null;\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nvar MISSING_VALUE = {};\nvar idCounter = 1;\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nvar makeSlotClass = function makeSlotClass() {\n  return (/** @class */function () {\n      function Slot() {\n        // If you have a Slot object, you can find out its slot.id, but you cannot\n        // guess the slot.id of a Slot you don't have access to, thanks to the\n        // randomized suffix.\n        this.id = [\"slot\", idCounter++, Date.now(), Math.random().toString(36).slice(2)].join(\":\");\n      }\n      Slot.prototype.hasValue = function () {\n        for (var context_1 = currentContext; context_1; context_1 = context_1.parent) {\n          // We use the Slot object iself as a key to its value, which means the\n          // value cannot be obtained without a reference to the Slot object.\n          if (this.id in context_1.slots) {\n            var value = context_1.slots[this.id];\n            if (value === MISSING_VALUE) break;\n            if (context_1 !== currentContext) {\n              // Cache the value in currentContext.slots so the next lookup will\n              // be faster. This caching is safe because the tree of contexts and\n              // the values of the slots are logically immutable.\n              currentContext.slots[this.id] = value;\n            }\n            return true;\n          }\n        }\n        if (currentContext) {\n          // If a value was not found for this Slot, it's never going to be found\n          // no matter how many times we look it up, so we might as well cache\n          // the absence of the value, too.\n          currentContext.slots[this.id] = MISSING_VALUE;\n        }\n        return false;\n      };\n      Slot.prototype.getValue = function () {\n        if (this.hasValue()) {\n          return currentContext.slots[this.id];\n        }\n      };\n      Slot.prototype.withValue = function (value, callback,\n      // Given the prevalence of arrow functions, specifying arguments is likely\n      // to be much more common than specifying `this`, hence this ordering:\n      args, thisArg) {\n        var _a;\n        var slots = (_a = {\n          __proto__: null\n        }, _a[this.id] = value, _a);\n        var parent = currentContext;\n        currentContext = {\n          parent: parent,\n          slots: slots\n        };\n        try {\n          // Function.prototype.apply allows the arguments array argument to be\n          // omitted or undefined, so args! is fine here.\n          return callback.apply(thisArg, args);\n        } finally {\n          currentContext = parent;\n        }\n      };\n      // Capture the current context and wrap a callback function so that it\n      // reestablishes the captured context when called.\n      Slot.bind = function (callback) {\n        var context = currentContext;\n        return function () {\n          var saved = currentContext;\n          try {\n            currentContext = context;\n            return callback.apply(this, arguments);\n          } finally {\n            currentContext = saved;\n          }\n        };\n      };\n      // Immediately run a callback function without any captured context.\n      Slot.noContext = function (callback,\n      // Given the prevalence of arrow functions, specifying arguments is likely\n      // to be much more common than specifying `this`, hence this ordering:\n      args, thisArg) {\n        if (currentContext) {\n          var saved = currentContext;\n          try {\n            currentContext = null;\n            // Function.prototype.apply allows the arguments array argument to be\n            // omitted or undefined, so args! is fine here.\n            return callback.apply(thisArg, args);\n          } finally {\n            currentContext = saved;\n          }\n        } else {\n          return callback.apply(thisArg, args);\n        }\n      };\n      return Slot;\n    }()\n  );\n};\nfunction maybe(fn) {\n  try {\n    return fn();\n  } catch (ignored) {}\n}\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable property of the globalThis object. This obfuscation does\n// nothing to prevent access to the Slot class, but at least it ensures the\n// implementation (i.e. currentContext) cannot be tampered with, and all copies\n// of the @wry/context package (hopefully just one) will share the same Slot\n// implementation. Since the first copy of the @wry/context package to be\n// imported wins, this technique imposes a steep cost for any future breaking\n// changes to the Slot class.\nvar globalKey = \"@wry/context:Slot\";\nvar host =\n// Prefer globalThis when available.\n// https://github.com/benjamn/wryware/issues/347\nmaybe(function () {\n  return globalThis;\n}) ||\n// Fall back to global, which works in Node.js and may be converted by some\n// bundlers to the appropriate identifier (window, self, ...) depending on the\n// bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224\nmaybe(function () {\n  return global;\n}) ||\n// Otherwise, use a dummy host that's local to this module. We used to fall\n// back to using the Array constructor as a namespace, but that was flagged in\n// https://github.com/benjamn/wryware/issues/347, and can be avoided.\nObject.create(null);\n// Whichever globalHost we're using, make TypeScript happy about the additional\n// globalKey property.\nvar globalHost = host;\nvar Slot = globalHost[globalKey] ||\n// Earlier versions of this package stored the globalKey property on the Array\n// constructor, so we check there as well, to prevent Slot class duplication.\nArray[globalKey] || function (Slot) {\n  try {\n    Object.defineProperty(globalHost, globalKey, {\n      value: Slot,\n      enumerable: false,\n      writable: false,\n      // When it was possible for globalHost to be the Array constructor (a\n      // legacy Slot dedup strategy), it was important for the property to be\n      // configurable:true so it could be deleted. That does not seem to be as\n      // important when globalHost is the global object, but I don't want to\n      // cause similar problems again, and configurable:true seems safest.\n      // https://github.com/endojs/endo/issues/576#issuecomment-1178274008\n      configurable: true\n    });\n  } finally {\n    return Slot;\n  }\n}(makeSlotClass());\nvar bind = Slot.bind,\n  noContext = Slot.noContext;\nfunction setTimeoutWithContext(callback, delay) {\n  return setTimeout(bind(callback), delay);\n}\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nfunction asyncFromGen(genFn) {\n  return function () {\n    var gen = genFn.apply(this, arguments);\n    var boundNext = bind(gen.next);\n    var boundThrow = bind(gen.throw);\n    return new Promise(function (resolve, reject) {\n      function invoke(method, argument) {\n        try {\n          var result = method.call(gen, argument);\n        } catch (error) {\n          return reject(error);\n        }\n        var next = result.done ? resolve : invokeNext;\n        if (isPromiseLike(result.value)) {\n          result.value.then(next, result.done ? reject : invokeThrow);\n        } else {\n          next(result.value);\n        }\n      }\n      var invokeNext = function invokeNext(value) {\n        return invoke(boundNext, value);\n      };\n      var invokeThrow = function invokeThrow(error) {\n        return invoke(boundThrow, error);\n      };\n      invokeNext();\n    });\n  };\n}\nfunction isPromiseLike(value) {\n  return value && typeof value.then === \"function\";\n}\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nvar wrappedFibers = [];\nfunction wrapYieldingFiberMethods(Fiber) {\n  // There can be only one implementation of Fiber per process, so this array\n  // should never grow longer than one element.\n  if (wrappedFibers.indexOf(Fiber) < 0) {\n    var wrap = function wrap(obj, method) {\n      var fn = obj[method];\n      obj[method] = function () {\n        return noContext(fn, arguments, this);\n      };\n    };\n    // These methods can yield, according to\n    // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n    wrap(Fiber, \"yield\");\n    wrap(Fiber.prototype, \"run\");\n    wrap(Fiber.prototype, \"throwInto\");\n    wrappedFibers.push(Fiber);\n  }\n  return Fiber;\n}\nexport { Slot, asyncFromGen, bind, noContext, setTimeoutWithContext as setTimeout, wrapYieldingFiberMethods };","map":{"version":3,"names":["currentContext","MISSING_VALUE","idCounter","makeSlotClass","Slot","id","Date","now","Math","random","toString","slice","join","prototype","hasValue","context_1","parent","slots","value","getValue","withValue","callback","args","thisArg","_a","__proto__","apply","bind","context","saved","arguments","noContext","maybe","fn","ignored","globalKey","host","globalThis","global","Object","create","globalHost","Array","defineProperty","enumerable","writable","configurable","setTimeoutWithContext","delay","setTimeout","asyncFromGen","genFn","gen","boundNext","next","boundThrow","throw","Promise","resolve","reject","invoke","method","argument","result","call","error","done","invokeNext","isPromiseLike","then","invokeThrow","wrappedFibers","wrapYieldingFiberMethods","Fiber","indexOf","wrap","obj","push"],"sources":["/Users/kenjifleming/course-challenges/Perfect-Parlay/perfect-parlay/client/node_modules/@wry/context/src/slot.ts","/Users/kenjifleming/course-challenges/Perfect-Parlay/perfect-parlay/client/node_modules/@wry/context/src/context.ts"],"sourcesContent":["type Context = {\n  parent: Context | null;\n  slots: { [slotId: string]: any };\n}\n\n// This currentContext variable will only be used if the makeSlotClass\n// function is called, which happens only if this is the first copy of the\n// @wry/context package to be imported.\nlet currentContext: Context | null = null;\n\n// This unique internal object is used to denote the absence of a value\n// for a given Slot, and is never exposed to outside code.\nconst MISSING_VALUE: any = {};\n\nlet idCounter = 1;\n\n// Although we can't do anything about the cost of duplicated code from\n// accidentally bundling multiple copies of the @wry/context package, we can\n// avoid creating the Slot class more than once using makeSlotClass.\nconst makeSlotClass = () => class Slot<TValue> {\n  // If you have a Slot object, you can find out its slot.id, but you cannot\n  // guess the slot.id of a Slot you don't have access to, thanks to the\n  // randomized suffix.\n  public readonly id = [\n    \"slot\",\n    idCounter++,\n    Date.now(),\n    Math.random().toString(36).slice(2),\n  ].join(\":\");\n\n  public hasValue() {\n    for (let context = currentContext; context; context = context.parent) {\n      // We use the Slot object iself as a key to its value, which means the\n      // value cannot be obtained without a reference to the Slot object.\n      if (this.id in context.slots) {\n        const value = context.slots[this.id];\n        if (value === MISSING_VALUE) break;\n        if (context !== currentContext) {\n          // Cache the value in currentContext.slots so the next lookup will\n          // be faster. This caching is safe because the tree of contexts and\n          // the values of the slots are logically immutable.\n          currentContext!.slots[this.id] = value;\n        }\n        return true;\n      }\n    }\n    if (currentContext) {\n      // If a value was not found for this Slot, it's never going to be found\n      // no matter how many times we look it up, so we might as well cache\n      // the absence of the value, too.\n      currentContext.slots[this.id] = MISSING_VALUE;\n    }\n    return false;\n  }\n\n  public getValue(): TValue | undefined {\n    if (this.hasValue()) {\n      return currentContext!.slots[this.id] as TValue;\n    }\n  }\n\n  public withValue<TResult, TArgs extends any[], TThis = any>(\n    value: TValue,\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ): TResult {\n    const slots = {\n      __proto__: null,\n      [this.id]: value,\n    };\n    const parent = currentContext;\n    currentContext = { parent, slots };\n    try {\n      // Function.prototype.apply allows the arguments array argument to be\n      // omitted or undefined, so args! is fine here.\n      return callback.apply(thisArg!, args!);\n    } finally {\n      currentContext = parent;\n    }\n  }\n\n  // Capture the current context and wrap a callback function so that it\n  // reestablishes the captured context when called.\n  static bind<TArgs extends any[], TResult, TThis = any>(\n    callback: (this: TThis, ...args: TArgs) => TResult,\n  ) {\n    const context = currentContext;\n    return function (this: TThis) {\n      const saved = currentContext;\n      try {\n        currentContext = context;\n        return callback.apply(this, arguments as any);\n      } finally {\n        currentContext = saved;\n      }\n    } as typeof callback;\n  }\n\n  // Immediately run a callback function without any captured context.\n  static noContext<TResult, TArgs extends any[], TThis = any>(\n    callback: (this: TThis, ...args: TArgs) => TResult,\n    // Given the prevalence of arrow functions, specifying arguments is likely\n    // to be much more common than specifying `this`, hence this ordering:\n    args?: TArgs,\n    thisArg?: TThis,\n  ) {\n    if (currentContext) {\n      const saved = currentContext;\n      try {\n        currentContext = null;\n        // Function.prototype.apply allows the arguments array argument to be\n        // omitted or undefined, so args! is fine here.\n        return callback.apply(thisArg!, args!);\n      } finally {\n        currentContext = saved;\n      }\n    } else {\n      return callback.apply(thisArg!, args!);\n    }\n  }\n};\n\nfunction maybe<T>(fn: () => T): T | undefined {\n  try {\n    return fn();\n  } catch (ignored) {}\n}\n\n// We store a single global implementation of the Slot class as a permanent\n// non-enumerable property of the globalThis object. This obfuscation does\n// nothing to prevent access to the Slot class, but at least it ensures the\n// implementation (i.e. currentContext) cannot be tampered with, and all copies\n// of the @wry/context package (hopefully just one) will share the same Slot\n// implementation. Since the first copy of the @wry/context package to be\n// imported wins, this technique imposes a steep cost for any future breaking\n// changes to the Slot class.\nconst globalKey = \"@wry/context:Slot\";\n\nconst host =\n  // Prefer globalThis when available.\n  // https://github.com/benjamn/wryware/issues/347\n  maybe(() => globalThis) ||\n  // Fall back to global, which works in Node.js and may be converted by some\n  // bundlers to the appropriate identifier (window, self, ...) depending on the\n  // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224\n  maybe(() => global) ||\n  // Otherwise, use a dummy host that's local to this module. We used to fall\n  // back to using the Array constructor as a namespace, but that was flagged in\n  // https://github.com/benjamn/wryware/issues/347, and can be avoided.\n  Object.create(null) as typeof Array;\n\n// Whichever globalHost we're using, make TypeScript happy about the additional\n// globalKey property.\nconst globalHost: typeof host & {\n  [globalKey]?: typeof Slot;\n} = host;\n\nexport const Slot: ReturnType<typeof makeSlotClass> =\n  globalHost[globalKey] ||\n  // Earlier versions of this package stored the globalKey property on the Array\n  // constructor, so we check there as well, to prevent Slot class duplication.\n  (Array as typeof globalHost)[globalKey] ||\n  (function (Slot) {\n    try {\n      Object.defineProperty(globalHost, globalKey, {\n        value: Slot,\n        enumerable: false,\n        writable: false,\n        // When it was possible for globalHost to be the Array constructor (a\n        // legacy Slot dedup strategy), it was important for the property to be\n        // configurable:true so it could be deleted. That does not seem to be as\n        // important when globalHost is the global object, but I don't want to\n        // cause similar problems again, and configurable:true seems safest.\n        // https://github.com/endojs/endo/issues/576#issuecomment-1178274008\n        configurable: true\n      });\n    } finally {\n      return Slot;\n    }\n  })(makeSlotClass());\n","import { Slot } from \"./slot\";\nexport { Slot }\nexport const { bind, noContext } = Slot;\n\n// Relying on the @types/node declaration of global.setTimeout can make\n// things tricky for dowstream projects (see PR #7).\ndeclare function setTimeout(\n  callback: (...args: any[]) => any,\n  ms?: number,\n  ...args: any[]\n): any;\n\n// Like global.setTimeout, except the callback runs with captured context.\nexport { setTimeoutWithContext as setTimeout };\nfunction setTimeoutWithContext(callback: () => any, delay: number) {\n  return setTimeout(bind(callback), delay);\n}\n\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nexport function asyncFromGen<\n  TArgs extends any[],\n  TYield = any,\n  TReturn = any,\n  TNext = any,\n>(\n  genFn: (...args: TArgs) => Generator<TYield, TReturn, TNext>\n) {\n  return function (this: any) {\n    const gen = genFn.apply(this, arguments as any);\n\n    type Method = (\n      this: Generator<TYield, TReturn, TNext>,\n      arg: any,\n    ) => IteratorResult<TYield, TReturn>;\n\n    const boundNext: Method = bind(gen.next);\n    const boundThrow: Method = bind(gen.throw!);\n\n    return new Promise((resolve, reject) => {\n      function invoke(method: Method, argument: any) {\n        try {\n          var result: any = method.call(gen, argument);\n        } catch (error) {\n          return reject(error);\n        }\n        const next = result.done ? resolve : invokeNext;\n        if (isPromiseLike(result.value)) {\n          result.value.then(next, result.done ? reject : invokeThrow);\n        } else {\n          next(result.value);\n        }\n      }\n      const invokeNext = (value?: any) => invoke(boundNext, value);\n      const invokeThrow = (error: any) => invoke(boundThrow, error);\n      invokeNext();\n    });\n  } as (...args: TArgs) => Promise<any>;\n}\n\nfunction isPromiseLike(value: any): value is PromiseLike<any> {\n  return value && typeof value.then === \"function\";\n}\n\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nconst wrappedFibers: Function[] = [];\nexport function wrapYieldingFiberMethods<F extends Function>(Fiber: F): F {\n  // There can be only one implementation of Fiber per process, so this array\n  // should never grow longer than one element.\n  if (wrappedFibers.indexOf(Fiber) < 0) {\n    const wrap = (obj: any, method: string) => {\n      const fn = obj[method];\n      obj[method] = function () {\n        return noContext(fn, arguments as any, this);\n      };\n    }\n    // These methods can yield, according to\n    // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n    wrap(Fiber, \"yield\");\n    wrap(Fiber.prototype, \"run\");\n    wrap(Fiber.prototype, \"throwInto\");\n    wrappedFibers.push(Fiber);\n  }\n  return Fiber;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}